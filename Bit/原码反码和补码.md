# 原码反码和补码

计算机在存储的时候是按8个比特位组成一个存储单元，叫一个字节，即一个字节等于8个比特，一个比特位能够表示两种信息，8个比特位就是表示2的八次方个信息，也就是256种不同的信息（状态），一个字节要是表示正数的话能够表示0~255或者1~256。数据在计算机中存储是有不同的编码方式，比如要存储一个数字，这个数字有正有负，在计算中这个正负是用这个字节的最高比特位来表示，剩下的比特位就是用来表示这个数的绝对值，最高位如果是0表示正数，如果是1表示负数，例如数字-2，它的绝对值是2，用二进制表示是10，而负号就是用1来表示，即10000010，如果是正2，则00000010

最高位是符号，剩下的位是绝对值，这种表示方式就叫原码

反码：如果是正数，则它的反码就等于原码，如果是负数，则它的反码就是除符号位按位取反，例如-2的源码是10000010，则反码为11111101。

补码：如果是正数，则它的补码就等于原码，如果是负数，则它的补码等于反码加1，还是以-2为例，它的补码为11111110。

在理解的时候，可以认为正数的源码，反码，补码没有区别。

计算机在存储数据的时候是按补码的方式来存储，为什么要这样呢？主要的目的是为了加法器能够同时实现加法和减法运算，比如要设计一个减法的时候，需不需要在CPU中设计一个减法器的电路，我们不希望这样，设计加法器电路，我们希望这个加法器电路也能够实现减法的计算，如何实现，能不能实现？

例如1-1=1+（-1） = 0

原码：00000001 + 10000001 = 10000010  = -2

反码：00000001 + 11111110 = 11111111

补码：00000001 + 11111111 = 00000000



取模运算

取模运算是求两个数相除的余数。取模主要是用于计算机术语中。



计算机的带符号数用补码表示的优点：

- 1负数的补码与对应正数的补码之间的转换可以用同一种方法-求补运算完成，可以简化硬件。
- 2 可将减法变为加法，这样减法就可以用加法器进行计算了。
- 3 两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃。

**5.有符号数与无符号数的相互转换**

无符号整数和有符号整数之间进行强制类型转换时，位模式不改变。

有符号数转换为无符号数时，负数转换为大的正数，相当于在原值上加上2的n次方，而正数保持不变。

无符号数转换为有符号数时，对于小的数将保持原值，对于大的数将转换为负数，相当于原值减去2的n次方。

当表达式中存在有符号数和无符号数类型时，所有的操作都自动转换为无符号类型。可见无符号数的运算优先级高于有符号数。



## 模的概念

 “模”这个概念来自计量系统，是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示模的余数。例如：时钟有12个刻度点，它所能表示的数只能是1~12之间，如果有数8，那么相当于时钟转了8个刻度，指向8点钟这个刻度点。用运算表示`8 mod 12 = 8`，其中12称为模，8称为取模的值。

“取模”是指获取计量器上“溢出”的量。还是以上面的例子为例，8就是溢出的量，但需要注意的是`32 mod 12`，其溢出量仍然是8，而不是20，因为32相当于转了时钟两圈，然后指向了刻度8，即是说，**溢出量必然是要小于“模”的**。

时钟能够顺时针，当然也能够逆时针，例如`-4 mod 12`就相当于时钟逆时针拨动4个刻度点，等价于顺时针拨动8个刻度点，即它取模的值就是8。

**模也可以用负数来表示**，例如`4 mod -12`，可能会很奇怪，“模”或者说时钟有几个刻度点还能用负数来表示吗？“模”用负数表示，就是让取模的值用反向（负数）表示而已，`4 mod -12`相当于顺时针拨动4个刻度点，等价于逆时针拨动8个刻度点，即取模的是为-8。

*其他数据示例：*

```c
36 mod -10 = -4
5 mod 3 = 2
-122 mod 256 = 134
134 mod -256 = -122
```

数学家针对上述取模的特点，归纳出了取模计算的数学公式：

```
对于整型数a，b来说，取模运算或者求余运算的方法都是：
1.求 整数商： c = [a/b];
2.计算模或者余数： r = a - c*b.
求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)。
例如计算：-7 Mod 4
那么：a = -7；b = 4；
第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）；
第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。
归纳：当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。
当符号不一致时，结果不一样。
```

**对于任何有模的计量器，其均可化为加减法运算。**

假设当前时钟时钟指向10点，而准确时间是5点，要调整到正确时间有以下两种拨法：

- 逆时针拨动5小时：10 - 5 = 5
- 顺时针拨动7小时：10 + 7 = 12 + 5 = 5

**对于“模”而言，-5和7互为补数**。以此类推互为补数还有1/11、3/9、4/8...，它们都有一个共同点：**补数绝对值之和等于模**。

**当给出“模”，并知道其中一个补数的时候，就可以计算得出另一个补数**。例如

```c
7 mod -12 = -5
-5 mod 12 = 7
```

Note：当求正数的补数时，“模”需要变为负数。

## 减法变加法运算原理

当明白了上面“模的概念”之后，就很容易明白计算机是如何将减法变加法运算的。





 







## 无符号数与有符号数



