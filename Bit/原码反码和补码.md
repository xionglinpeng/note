# 原码反码和补码

计算机存储以8个比特位为一个存储单元，叫一个字节，即一个字节等于8个比特，一个比特位能够表示两种信息，8个比特位就是表示2的八次方个信息，也就是256种不同的信息（状态），一个字节要是表示正数的话能够表示0~255或者1~256。数据在计算机中存储是有不同的编码方式，比如要存储一个数字，这个数字有正有负，在计算中这个正负是用这个字节的最高比特位来表示，剩下的比特位就是用来表示这个数的绝对值，最高位如果是0表示正数，如果是1表示负数。例如数字-2，它的绝对值是2，用二进制表示是10，而负号就是用1来表示，即10000010，如果是正2，则00000010。

- 原码：最高位是符号，剩下的位是绝对值，这种表示方式就叫
- 反码：如果是正数，则它的反码就等于原码，如果是负数，则它的反码就是除符号位按位取反，例如-2的源码是10000010，则反码为11111101。
- 补码：如果是正数，则它的补码就等于原码；如果是负数，则它的补码等于反码加1，还是以-2为例，它的补码为11111110。

在理解的时候，可以认为正数的原码，反码，补码没有区别。

计算机在存储数据的时候是按补码的方式来存储，主要的目的是为了加法器能够同时实现加法和减法运算——将本身是减法的运算转换为加法。

计算机按补码存储数据的优点：

- 正数的补码和对应负数的补码之间的转换可以用同一种方式——取模运算完成。
- 可以将减法运算转换为加法运算，在硬件层面上可以省略一个减法器电路。

## 取模运算

 “模”这个概念来自计量系统，是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示模的余数。例如：时钟有12个刻度点，它所能表示的数只能是1~12之间，如果有数8，那么相当于时钟转了8个刻度，指向8点钟这个刻度点。用运算表示`8 mod 12 = 8`，其中12称为模，8称为取模的值。

“取模”是指获取计量器上“溢出”的量。还是以上面的例子为例，8就是溢出的量，但需要注意的是`32 mod 12`，其溢出量仍然是8，而不是20，因为32相当于转了时钟两圈，然后指向了刻度8，即是说，**溢出量必然是要小于“模”的**。

时钟能够顺时针，当然也能够逆时针，例如`-4 mod 12`就相当于时钟逆时针拨动4个刻度点，等价于顺时针拨动8个刻度点，即它取模的值就是8。

**模也可以用负数来表示**，例如`4 mod -12`，可能会很奇怪，“模”或者说时钟有几个刻度点还能用负数来表示吗？“模”用负数表示，就是让取模的值用反向（负数）表示而已，`4 mod -12`相当于顺时针拨动4个刻度点，等价于逆时针拨动8个刻度点，即取模的是为-8。

*其他数据示例：*

```c
36 mod -10 = -4
5 mod 3 = 2
-122 mod 256 = 134
134 mod -256 = -122
```

数学家针对上述取模的特点，归纳出了取模计算的数学公式：

```
对于整型数a，b来说，取模运算或者求余运算的方法都是：
1.求 整数商： c = [a/b];
2.计算模或者余数： r = a - c*b.
求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)。
例如计算：-7 Mod 4
那么：a = -7；b = 4；
第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）；
第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。
归纳：当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。
当符号不一致时，结果不一样。
```

**对于任何有模的计量器，其均可化为加减法运算。**

假设当前时钟时钟指向10点，而准确时间是5点，要调整到正确时间有以下两种拨法：

- 逆时针拨动5小时：10 - 5 = 5
- 顺时针拨动7小时：10 + 7 = 12 + 5 = 5

**对于“模”而言，-5和7互为补数**。以此类推互为补数还有1/11、3/9、4/8...，它们都有一个共同点：**补数绝对值之和等于模**。

**当给出“模”，并知道其中一个补数的时候，就可以计算得出另一个补数**。例如

```c
7 mod -12 = -5
-5 mod 12 = 7
```

Note：当求正数的补数时，“模”需要变为负数。

## 减法变加法运算原理

当明白了上面“模的概念”之后，就很容易明白计算机是如何将减法变加法运算的。

计算机中一个字节占8个比特位，最多可以表示256种状态，因此可以认为它就是一个计量器，“模”就是256。又因为最高位为符号位，不考虑符号位的情况下，最多可以表示127种状态。最高位为0表示正向计算，最高位为1表示反向计算，因此补数的取值范围为-128~127。前面已经说过，“对于任何有模的计量器，其均可化为加减法运算”。

例如：

```
-95 mod 256 = 161
```

-95与161互为补数。假设有一个数50

```
50 - 95 = 256 - 45 = 211
50 + 161 = 211
```

分析-95和161的原码，反码，补码

```
161 =>
原码：10100001
反码：10100001
补码：10100001

-95 =>
原码：11011111
反码：10100000
补码：10100001 = 161
```

可以看到-95的补码10100001刚好是161，当`n-95`的时候就可以转换成`n+161`。

假设n = 200

```
n - 95 = 105
# 将n转换为二进制
1100,1000 (200) + 1010,0001 (161) = 1,0110,1001
```

相加之后结果为1,0110,1001，因为只有8个比特位，因此溢出位数舍弃，即0110,1001，转换成10进制，刚好是105。

## 无符号数与有符号数

从表面上看，无符号数与有符号数的区别就在于最高位是否是符号位，如果是，则就是有符号数，如果不是，则就是无符号数据。但对于计算机而言，它可不认得那些是符号位，那些不是，也不知道存储的数据是原码，反码，还是补码，它只是按照硬件所定义的方式去运行。上面的这些信息都是由程序所定义，但由于硬件只有加法器电路，因此由“减法变加法运算原理”，在计算机中存储的都是补码。**补码是没有符号位的，原码的最高位为符号位，因此可以认为由原码所表示的数是有符号数，由补码所表示的数是无符号数**。

> 那些是符号位，那些不是由编程语言所定义。例如在Java语言中，byte类型长1一个字节，8个比特位，因此从右向左，第8位为符号位，可以有7位表示数据；int类型长4个字节，32个比特位，因此从右向左，第32位为符号位，可以有31位表示数据；依次类推，其他类型也是一样的。

*有符号数与无符号数的相互转换*

有符号数与无符号数的相互转换知道原补码，知道补码求原码；或者说知道原码或补码、数据类型，对应的模值，进行取模运算。

