# 线程安全与锁优化



## 2、线程安全



2.1、Java语言中的线程安全



2.2、线程安全的实现方法

2.2.1、互斥同步





2.2.2、非阻塞同步

## 3、锁优化





3.1、自旋锁与自适应自旋锁



3.2、锁消除



3.3、锁粗化



3.4、轻量级锁

`synchronized`关键字Java中的多线程同步方案，它是基于互斥量的互斥同步操作。我们知道Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，就不可避免地陷入到用户态和核心态的转换。进行这种状态的转换需要耗费很多处理器时间。尤其是同步代码块特别简单时候，其状态转换的时间甚至比用户代码本身的执行时间还长。因此`synchronized`是一个很重量级的操作，也称其为重量级锁。

轻量级锁是JDK 6时加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的因此传统的锁机制就被称为“重量级”锁。不过，需要强调的是，轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。

读到这里你可能会感觉很疑惑，“没有多线程竞争的前提下”这句话，既然说没有多线程竞争，那为什么还要加锁呢？如果要加锁，则必然是存在竞争的。没错，确实是这样，但一段同步代码并不是在任何时候都有多个线程在竞争执行，可能某一段时间只有一个线程在执行它，或者虽然有多个线程，它们在顺序执行同步代码块，没有产生交叉。

那么轻量级锁是如何减少传统重量级锁所产生的性消耗的呢？一个最简单的方案就是给同步代码块的同步对象加一个标记，标记已经有一个线程在执行了，执行完成之后，再将标记还原。如果在执行的过程中，有另一个线程也来执行了，则不停的轮询，等待标记重置，然后再去执行。没错，这就是CAS，基于CAS的原理，就可以完美地解决没有竞争情况下重量级锁的性能损耗，虽然会有一点CPU资源的消耗，但相比于用户态和核心态的转换，其产生的性能损耗是大大减少了。

但这里还有一个问题，如果同步代码块的所需的执行时间非常长，怎么办？，如果没有线程来竞争或者同步代码块的执行时间非常短暂，这没有任何问题。但既然加锁，必然是存在竞争的，也不可能保证同步代码块的执行时间一定非常短暂。所以当有线程来竞争的时候，不可能让其一直轮询，这只会白白消耗处理器自身的资源，而不会做任何有价值的工作，这就带来了性能上的浪费。因此这个的轮询等待的时间必须有一个限制，如果轮询的超过了限定的次数仍然没有等到标记重置，就直接使用传统的方式挂起线程。在这种情况下线程的切换也就算不上什么性能消耗了。

上面说明了轻量级锁的目的以及它是如何减少传统重量级锁使用操作系统互斥量产生的性能消耗的。下面将说明轻量级锁的运作原理。要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须要对HotSpot虚拟机对象的内存局部（尤其是对象头部分）有所了解。这里假定你已经有所了解。





















在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时线程堆栈与对象头的状态如下图所示：

注意，这个时候仅仅是建立了Lock Record空间，但还没有拷贝。



然后虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表改线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时线程堆栈与对象头的状态如下图所示：



如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取改对象的锁。虚拟机首先会检查对象的Mark Word是否执行当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。

如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时Mark Word中存在的就是执行重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。





3.5、偏向锁

当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”，把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的JavaThread*记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。



https://xie.infoq.cn/article/4c7cd2c5d4d004b4bc1c381b7

https://github.com/openjdk/jdk/blob/master/src/hotspot/share/oops/markWord.hpp

https://github.com/openjdk/jdk/blob/master/src/hotspot/share/oops/oop.inline.hpp

https://github.com/openjdk/jdk/blob/master/src/hotspot/share/runtime/synchronizer.cpp

https://www.zhihu.com/question/29976202

https://www.cnblogs.com/noures/archive/2012/04/20/2458793.html

https://www.cnblogs.com/dennyzhangdd/p/6734638.html

https://www.cnblogs.com/katsu2017/p/12610002.html

https://zhanghaoxin.blog.csdn.net/article/details/108627063

https://paoluz.link/user/shop

https://www.jianshu.com/p/36eedeb3f912

https://www.jianshu.com/p/4758852cbff4

https://www.jianshu.com/p/7445361e187f

http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/runtime/biasedLocking.cpp#l146

https://www.zhihu.com/question/57774162







