# 虚拟机类加载机制

## 类加载的时机

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称做虚拟机的类加载机制。

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历**加载（Loading）**、**验证（Verification）**、**准备（Preparation）**、**解析（Resolution）**、**初始化（Iniaialization）**、**使用（Using）**和**卸载（Unloading）**七个阶段，其中验证、准备、解析三个阶段统称为**连接（Linking）**。如下图所示：

![1600321612288](C:\Users\chinasoft.lp.xiong\AppData\Roaming\Typora\typora-user-images\1600321612288.png)





《Java虚拟机规范》严格规定了**有且只有**六种情况必须立即对类进行“初始化”：

1. 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。

   能够生产这四条指令的典型Java代码场景：

   - 使用`new`关键字实例化对象的时候。
   - 读取（`getstatic`）或设置（`putstatic`）一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
   - 调用（`invokestatic`）一个类型的静态方法的时候。

2. 使用`java.lang.reflect`包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。

3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含`main()`方法的那个类），虚拟机会先初始化这个主类。

5. 当使用JDK7新加入的动态语言支持时，如果一个java.lang.MethodHandle实例最后的解析结果为`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`、`REF_newInvokeSpecial`四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

6. 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动应用。







`-XX:+TraceClassLoading`：

接口的加载过程与类的加载过程稍有不同：

类：当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

接口：一个接口在初始化时，并不要求其父接口全部完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

## 3、类加载的过程

### 3.1、加载

在加载阶段，Java虚拟机需要完成以下三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

注意，《Java虚拟机规范》对上述三点要求并不是特别具体，留给虚拟机实现与Java应用的灵活度都相当大。例如“通过一个类的全限定名来获取定义此类的二进制字节流”这条规则，它并没有指明二进制字节流从哪里获取，如何获取。所以可以通过任何来源去获取，只要给它一个代表Class的二进制字节流即可。例如：

- 从ZIP压缩包中读取。常见有jar、ear、war等格式。
- 从网络中获取。典型的应用就是Web Applet。
- 运行时计算生成。最常见的就是动态代理技术，在`java.lang.reflect.Proxy`中就是用了`ProxyGenerator.generateProxyClass()`来为特定接口生成形式为`*$Proxy`的代理类的二进制字节流。
- 由其他文件生成。典型的场景就是JSP应用，由JSP文件生成对应的Class文件。
- 从数据库中读取。这种场景相对少见。例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。
- 从加密文件中获取。这是典型的防Class文件被反编译的保护措施，通过加载时加密Class文件类保障程序运行逻辑不被窥探。例如开源软件防破解。

对于数组类而言，情况有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Elemet Type，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载。一个数组类的创建过程遵循以下规则：

- 如果数组的组件类型（Component Type，指的是去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用普通类的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。
- 如果数组的组件类型不是引用类型，Java虚拟机将会把数组C标记为与引导类加载器关联。
- 数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为`public`，可被所有的类和接口访问。

加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个`java.lang.Class`类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。

加载阶段与连接阶段的部分动作（如一部分字节码文件格式的验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在夹在阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。

### 3.2、验证









