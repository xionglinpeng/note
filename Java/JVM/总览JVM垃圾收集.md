# 总览JVM垃圾收集

JVM的垃圾收集器随着时间的推移越来越强大，性能越来越好，但也变得越来越复杂了。万变不离其中，无论怎么样变，JVM的垃圾收集都是围绕两个核心目的去实现：

1. 找到垃圾
2. 回收垃圾

现在我们回到Java诞生的时候，顺着历史的轨迹，来看看JVM的垃圾收集器是如何围绕着两个目的去演变的。

Java是一款基于JVM自动管理内存的变成语言，既然是自动管理内存，那必然就涉及到了内存的分配与回收，这里仅对于内存回收而言，需要实现两个目的，找到垃圾和回收垃圾。现在问题来了，要如何找到垃圾呢？至于回收垃圾就相对简单多了，找到所有是垃圾的内存，然后将其清空就OK了。

现在，我们回到如何找到垃圾这个问题，要找到垃圾，就要明白，什么才是垃圾。Java语言是一个面向对象的编程语言，如果一个对象没有被引用，也就是永远都不会被使用了，也就是说，这个对象占用了内存空间，却没有任何作用，这不是垃圾是什么，因此，我们可以定义没有被引用的对象就是垃圾。那事情就简单了，既然没有被引用的对象就是垃圾，那只需要找出所有对象并判断有没有引用不就OK了吗。事实也是这样的，进而诞生了引用计数法，但引用计数法却存在对象循环引用的问题。为了解决这个问题，使用了可达性分析算法。可达性分析算法是OK的，它可以找到所有的存活对象，解决了对象循环引用的问题，剩下的自然就是需要回收的垃圾了，现在，是时候回收了。事情就是这么简单。

但是在真正实现的时候却面临两个问题：

1. 什么时候进行垃圾回收。
2. 查找垃圾的时候，本来标记为垃圾了，之后又变成不是垃圾了怎么办？这个问题很严重啊，必须要解决。

第一个问题好解决，当然是内存不够用了就进行垃圾回收啊，以腾出空间给新的对象分配。

但是第二个问题呢？如果查找垃圾的时候产生了新的垃圾，被遗漏了，这没有太大影响，下一次打扫就好了嘛。但是将不是垃圾的对象回收了就会破坏程序的正确性，这是绝对不可以的，怎么办？好办啊，在打扫垃圾时候使其不会产生垃圾，也就是垃圾回收的停止程序的运行不就可以了吗，因此诞生了STW（Stop The World）。内存不够用了，就启动STW，此时所有的用户线程被暂停，只有唯一一个GC线程在运行，待垃圾回收完毕之后，停止STW，即恢复用户线程的执行。Serial和Serial Old垃圾收集器就是这种方式的典型实现。

现在，我们已经解决了所有的问题，可以正确的回收垃圾，是时候更进一步了，我们希望让它更快。

第一个最直观的优化点就是多线程，一个GC线程和多个GC线程的效率肯定是不一样，虽然多线并不是在所有的情况下都高效（比如只有一个内核），但在大多数情况下都是很好的一个选择，因为在今天即使是个人PC机，都是多核的了。ParNew、Parallel Old和Parallel Scavenge这三个垃圾收集器就是按这种方式实现的。











Serial *最早的垃圾回收器*,JDK 1.3.1 之前新生代唯一的垃圾回收器,使用的是单线程串行回收方式,在单 CPU 环境下性能较好,因为单线程执行不存在线程切换

