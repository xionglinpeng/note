# CA证书

说到CA证书，我们的第一映像是HTTPS，好像CA证书是用来进行安全通信用的。可以它是如何进行安全通信？，CA证书又是什么？这就不得而知了。

## 加密通信

## 一个加密通信过程的演化

此演示例子引用至：http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html

为了说明这两个问题，首先来看一个加密通信过程的演化：

我们来看一个例子：现在假设“服务器”和“客户”要在网络上通信，并且它们打算使用RSA（参看附录RSA简介）来对通信进行加密以保证通信内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥（如何公布，后面再讲），自己保留私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，“客户”并不知道私钥。下面我们再来看一下双方如何进行安全通信：

### NO.1

```
客户—>服务器：你好
客户<—服务器：你好，我是服务器
客户—>服务器：你好，这是我的银行卡密码
```

这里有个问题，因为消息是网络上传递的，所以黑客可以拦截“客户”和“服务器”之间的通信，在客户不知道的情况下，冒充服务器，如下：

```
# 黑客拦截了客服发给服务器的请求
客户—>黑客：你好
客户<—黑客：你好，我是服务器
客户—>黑客：你好，这是我的银行卡密码
```

### NO.2

黑客拿到了你的银行卡密码会发生什么还用说吗。那怎么办呢？使用RSA加密？没错，使用RSA确实可以解决黑客冒充的问题。过程如下：

```
客户—>服务器：(RSA publicKey)你好
客户<—服务器：(RSA privateKey)你好，我是服务器
客户—>服务器：(RSA publicKey)你好，这是我的银行卡密码
```

客服使用服务器的公钥对信息加密，服务器使用自己的私钥对信息加密。

假设黑客冒充服务器会怎样呢？

```
客户—>黑客：(RSA publicKey)你好
	黑客解密：？？？
客户<—黑客：(RSA privateKey)你好，我是服务器
	客户解密：？？？
客户—>黑客：？？？
```

因为黑客是没有服务器的私钥的，所以客户用服务器公钥加密的内容黑客是无法解密的。同样，黑客发送给客户的内容要么没有加密，要么加密了，但是无论如何，客户都不可能用服务器的公钥对其进行解密。如果能够解密，那么就就可以证明，这个消息必定是服务器发送过来的。

### NO.3

到了这里，确实可以证明信息交互的对象确实是服务器。但是，即使是这样，还是不能保证信息的安全，为什么呢？不是已经使用了RSA公私钥加密了吗？因为公钥是公开的，虽然因为私钥只有服务器知道，黑客无法解密客户发送给服务器的信息，但是服务器发给客户的信息，黑客是可以解密的。

```
客户—>服务器：(RSA publicKey)你好
客户<—服务器：(RSA privateKey)你好，我是服务器
客户—>服务器：(RSA publicKey)你好，我申请一个账号密码
客户<—服务器：(RSA privateKey)你好，你的账号密码是******
```

黑客只要拦截客户与服务器交互的信息，用服务器公开的公钥解密服务器发给客户的信息，就可以知道客户的账号密码是什么了。那怎么办呢？可以引入DES对称加密来解决这个问题。请看下面的演示：

### NO.4

```
客户—>服务器：(RSA publicKey)你好
客户<—服务器：(RSA privateKey)你好，我是服务器{这里就可以确认服务器的身份了}
客户—>服务器：(RSA publicKey)你好，这是对称加密秘钥
客户<—服务器：(DES key)好的，已收到DES秘钥
客户—>服务器：(DES key)我申请一个账号密码
客户<—服务器：(DES key)你的账号密码是******
```

客户在确认交互的对象确实是服务器之后，就生成一个秘钥和选择一个对称加密算法，将对称加密算法和秘钥使用服务器的公钥加密之后发送给服务器（因为使用了服务器的公钥加密，黑客就算拿到了加密信息，也不能解密从而知道对称加密信息）。服务器使用自己的私钥对其进行解密，从而就生成了一个只有客户和服务器知道的对称加密算法和秘钥了，之后的信息交互就使用对称加密算法进行交互。

### 总结

- 因为私钥只有服务器拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。
- 客户通过RSA的掩护，安全地和服务器商量好一个对称加密算法和秘钥来保护后面的通信内容的安全。

到了这里，客户和服务器的通信好像比较安全了。但是又回到最初的问题，那就是服务器如何发布自己的公钥呢，并使客户知道？我们可能会想到三个方法：

1. 把公钥放到互联网的一个指定地址，事先客户去下载。
2. 和客户联系，事先将公钥告诉它，比如线下联系等。
3. 每次通信交互时，将公钥发给客户。

对于第一个方式，客户凭什么这个下载地址是下载的公钥是服务器，而不是别人冒充的；

对于第二种方式，互联网的用户成千上万，难道和每一个都去联系？

对于第三种方式，黑客可以直接拦截将自己的公钥发给客户；

那么怎么办呢？如果能够证明拿到的公钥确实是服务器的就好了。为了解决这个问题，数字证书出现了，数字证书可以解决上面的问题。那么数字证书又是什么呢？

## 数字证书

下面是百科百科的描述：

> 数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，数字证书不是[数字身份证](https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E8%AF%81/680163)，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。它是由权威机构——CA机构，又称为证书授权（Certificate Authority）中心发行的，人们可以在网上用它来识别对方的身份。

简单来说，数字证书就是由CA机构发行认证的存储有通讯各方身份信息的一串数字，通过这串数字，可以验证通讯实体（比如这里的服务器）的身份。

*那么它是如何验证其身份的呢？*

在说明这个问题之前，我们先来看一下加入数字证书的加密通信的完整过程：

> 首先用户（比如这里的服务器）向CA机构申请一张数字证书，CA机构认证并签名，生成数字证书发给用户。用户开始使用数字证书：以SSL为例，客户端在访问HTTPS服务器时，首先服务器会生成一个签名，并将**自己的证书**和**签名**以及**报文**一起发给客户端，客户端拿到证书之后，客户端验证证书，拿到证书中服务器的公钥，使用服务器的公钥校验服务器签名，校验通过之后，协商对称秘钥。

看到这里大家可能更加懵逼了，因此这段简单的描述有很多没有描述清楚的地方，总结了问题如下：

1. 用户如何向CA机构申请数字证书？
2. CA机构如何认证？
3. 签名是什么，如何签名？
4. 服务器为什么要生成一个自己的签名？
5. 服务器发给客户端的**自己的证书**和**签名**以及**报文**，这里的报文是什么？
6. 客户端是如何验证证书的？
7. 为什么是从证书中拿到服务器的公钥？
8. 什么是使用服务器公钥校验服务器签名？
9. 为什么服务器签名校验通过之后就商量对称秘钥了？

我们来一个一个解答，当所有这些问题都明白之后，就能理解“加入数字证书的加密通信的完整过程”了。

#### 一、用户如何向CA机构申请数字证书？

用户首先产生自己的[密钥](https://baike.baidu.com/item/%E5%AF%86%E9%92%A5)对，并将公共密钥及部分个人身份信息传送给[认证中心](https://baike.baidu.com/item/%E8%AE%A4%E8%AF%81%E4%B8%AD%E5%BF%83)。

#### 二、CA机构如何认证？

认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来。

#### 三、签名是什么，如何签名？

签名又叫数字签名。

数字签名（又称[公钥](https://baike.baidu.com/item/%E5%85%AC%E9%92%A5)数字签名、[电子签章](https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E7%AD%BE%E7%AB%A0/4076522)）是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术实现，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。

数字签名，就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。

数字签名是非对称[密钥加密技术](https://baike.baidu.com/item/%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF)与[数字摘要](https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E6%91%98%E8%A6%81/4069118)技术的应用。

如何签名呢？

首先生成一个报文（参见第五个问题），使用一个HASH算法计算报文的hash值，CA机构使用自己的私钥对hash值进行加密，加密后生成的值即是签名。



CA机构是有自己的证书的，这个证书可能是根证书（自签名证书），也可能是在证书链中由上级CA机构签发的证书，无论是哪一种，它都有自己的公钥和私钥。

CA机构在认证通过之后，将用户的公钥和用户信息绑定在一个，并为之签字（用户的公钥和用户信息作为报文计算hash值，CA机构用自己的私钥对生成的hash值加密）生成数字证书。

结构类似：【用户公钥|信息】【签名】—>数字证书；当然，数字证书肯定不会这么简单，但是这是其核心。

#### 四、服务器为什么要生成一个自己的签名？

我们再次回顾一下前面“一个加密通信过程的演化”的例子，客户拿到了服务器的公钥，需要确认交互的对象确实是服务器，而不是黑客冒充的，是怎么实现的？

同样的道理，数字证书虽然保证了客户拿到的公钥确实是服务器的，但是却不能保证交互的对象就是服务器，或者说这个证书就是服务器发过来的，再或者是证书确是服务器发过来的，但是又如何保证在传输的过程中没有被破坏或篡改呢？虽然客户发送的信息会使用公钥加密，即使交互的对象不是服务器，黑客也不能破译，但是如果黑客故意搞破坏呢。

所以，就需要证明交互的对象确实是服务器，证书确实是服务器发过来的，并且证书也没有被篡改。但是如何证明呢？

在“一个加密通信过程的演化”的例子中已经说明了，服务器不能在与客户首次交互的时候将它的公钥发给客户端，因为黑客可以拦截发送黑客自己的公钥，也不能到指定的地址去下载，因为不能保证下载的公钥就是服务器的，所以需要服务器和客户进行一次交互以相互确认身份。

但是当使用数字证书的时候需要怎么做呢，数字证书本身就能保证公钥确实是服务器的，与其多一次交互，不如服务器直接就在将证书发送给客户的时候，将自己的证明信息连同证书一起发送给客户，客户直接进行校验就可以了。而这个服务器的证明信息就是签名（数字签名）。

> 那么如何签名？又是如何证明的呢？请参看第八个问题。

#### 五、服务器发给客户端的**自己的证书**和**签名**以及**报文**，这里的报文是什么？

这里的报文，可能是一串随机字符串，也可能是其他信息。

#### 六、客户端是如何验证证书的？

客户端拿到服务器的证书之后，证书是经过可信任CA机构签字的，所在浏览器的证书链中找到对应CA机构的公钥，有了CA机构的公钥即可校验CA机构的签名，校验通过，即表明这个证书确实是该权威CA机构签发的，也证明服务器的证书是可信任的。

> 如何校验？为什么可以证明是CA机构签发的，并且是可信任的？参见第八个问题。

#### 七、为什么是从证书中拿到服务器的公钥？

在第三个问题中已经说过，CA机构是将用户的公钥和用户的信息作为报文进行签名的，然后生成一张数字证书，其用户的公钥和用户的信息是通过明文存储在数字证书中的，而其有效性是通过其签名验证的。所以只要拿到数字证书，即表示拿到了服务器的公钥。

#### 八、什么是使用服务器公钥校验服务器签名？

服务首先生成一个报文，使用hash算法(消息摘要算法)计算报文的hash值，服务器在使用自己的私钥对hash进行加密生成签名。之后将数字证书、报文连同签名一同发给客户。

客户端收到服务器数字证书、报文和签名，首先验证数字证书，取到其中的服务器公钥，解密签名，得到报文的hash值，这里能够解密，那么也就证明了，消息确实是服务器发给过来的，即不可否认性。然后再计算报文的hash值，与解密之后的hash做对比，如果一致，即此消息没有被破坏或篡改，即完整性。

到了这里，就已经证明了消息证书确实是服务器发过来的，并且消息也没有被破坏或篡改。



证书链

证书由权威认证机构颁发，其内容包含证书所有者的标识和它的公钥，并由权威认证机构使用它的私钥进行签名。信息的发布者通过在网络上发布证书来公开它的公钥，该证书由权威认证机构进行签名，认证机构也是通过发布它的证书来公开该机构的公钥，认证机构的证书由更权威的认证机构进行签名，这样就形成了证书链。证书链最顶端的证书称为根证书，根证书就只有自签名了。总之，要对网络上传播的内容进行签名和认证，就一定会用到证书。关于证书遵循的标准，最流行的是 X.509



## 数字签名是什么？

引用阮一峰博客：http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html

1. 鲍勃有两把钥匙，一把是公钥，另一把是私钥。
2. 鲍勃把公钥送给他的朋友们-----帕蒂、道格、苏珊----每人一把。
3. 苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。
4. 鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。
5. 鲍勃给苏珊回信，决定采用"数字签名"。他写完后先用Hash函数，生成信件的摘要（digest）。
6. 然后，鲍勃使用私钥，对这个摘要加密，生成"数字签名"（signature）。
7. 鲍勃将这个签名，附在信件下面，一起发给苏珊。
8. 苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。
9. 苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。
10. 复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成"数字签名"，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。
11. 后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找"证书中心"（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成"数字证书"（Digital Certificate）。
12. 鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。
13. 苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明"数字签名"是否真的是鲍勃签的。
14. 下面，我们看一个应用"数字证书"的实例：https协议。这个协议主要用于网页加密。
15. 首先，客户端向服务器发出加密请求。
16. 服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。
17. 客户端（浏览器）的"证书管理器"，有"受信任的根证书颁发机构"列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。
18. 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。
19. 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。
20. 如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。



SSL证书

> **1.浏览器将自己支持的一套加密规则发送给网站。 2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器**。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 
> **3.浏览器获得网站证书之后浏览器要做以下工作**： 
> a) **验证证书的合法性**（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。 
> b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 
> c) **使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密**，最后将之前生成的所有信息发送给网站。 
> **4.网站接收浏览器发来的数据之后要做以下的操作：** 
> a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 
> b) 使用密码加密一段握手消息，发送给浏览器。 
> **5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密**。

​      这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。另外，HTTPS一般使用的加密与HASH算法如下：

>
> ​      非对称加密算法：RSA，DSA/DSS 
> ​      对称加密算法：AES，RC4，3DES 
> ​      HASH算法：MD5，SHA1，SHA256



关于数字签名、CA认证、CA证书、SSL证书的更详细说明请参看百度百科：

数字签名：https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D#3

数字证书：https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/326874?fr=aladdin

CA认证：https://baike.baidu.com/item/CA%E8%AE%A4%E8%AF%81/6471579#4

CA证书：https://baike.baidu.com/item/ca%E8%AF%81%E4%B9%A6/10028741?fr=aladdin

SSL证书：https://baike.baidu.com/item/SSL%E8%AF%81%E4%B9%A6/5201468?fr=aladdin



## 管理证书

### Windows

在cmd上执行mmc

文件—>添加删除管理单元—>在可用的管理单元中找到证书—>添加—>确定

#### makecert.exe

每个证书发布机构都有自己的用来创建证书的工具，不同类型的证书都有一段的格式和规范。微软为我们提供了一个用来创建证书的工具`makecert.exe`，在安装Visual Studio的时候会安装上，如果没有安装也无所谓，可以上网去下载一个，搜索`makecert`就可以了。

我们用到的是`makecert`这个工具，微软有很详细的使用帮助，我这里只做一个简单的解释，详细的工作参数和使用方法请查看[MSDN的makecert的帮助](http://msdn.microsoft.com/zh-cn/library/bfsktky3(VS.80).aspx)。

**基本选项：**

```bash
C:\Users\xlp>makecert -？
Usage: MakeCert [ basic|extended options] [outputCertificateFile]
Basic Options
 -sk  <keyName>      Subject's key container name; To be created if not present
 -pe                 Mark generated private key as exportable
 -ss  <store>        Subject's certificate store name that stores the output
                     certificate
 -sr  <location>     Subject's certificate store location.
                        <CurrentUser|LocalMachine>.  Default to 'CurrentUser'
 -#   <number>       Serial Number from 1 to 2^31-1.  Default to be unique
 -$   <authority>    The signing authority of the certificate
                        <individual|commercial>
 -n   <X509name>     Certificate subject X500 name (eg: CN=Fred Dews)
 -?                  Return a list of basic options
 -!                  Return a list of extended options
```

**properties**

- `-sk`：指定主题的密钥容器位置，该位置包含私钥。如果密钥容器不存在，系统将创建一个。
- `-pe`：将所生成的私钥标记为可导出。这样可将私钥包括在证书中。
- `-ss`：指定主题的证书存储名称，输出证书即存储在那里。
- `-sr`：指定主题的证书存储位置。*Location* 可以是 **currentuser**（默认值）或 **localmachine**。
- `-#`：指定一个介于 1 和 2,147,483,647 之间的序列号。默认值是由 Makecert.exe 生成的唯一值。
- `-$`：指定证书的签名权限，必须设置为 **commercial**（对于商业软件发行者使用的证书）或 **individual**（对于个人软件发行者使用的证书）。
- `-n`：指定主题的证书名称。此名称必须符合 X.500 标准。最简单的方法是在双引号中指定此名称，并加上前缀 **CN=**；例如，"CN=*myName*"。
- `-?`：显示此工具的命令语法和基本选项列表。
- `-!`：显示此工具的命令语法和扩展选项列表。

**扩展选项：**

```bash
C:\Users\xlp>makecert -!
Usage: MakeCert [ basic|extended options] [outputCertificateFile]
Extended Options
 -tbs <file>         Certificate or CRL file to be signed
 -sc  <file>         Subject's certificate file
 -sv  <pvkFile>      Subject's PVK file; To be created if not present
 -ic  <file>         Issuer's certificate file
 -ik  <keyName>      Issuer's key container name
 -iv  <pvkFile>      Issuer's PVK file
 -is  <store>        Issuer's certificate store name.
 -ir  <location>     Issuer's certificate store location
                        <CurrentUser|LocalMachine>.  Default to 'CurrentUser'
 -in  <name>         Issuer's certificate common name.(eg: Fred Dews)
 -a   <algorithm>    The signature algorithm
                        <md5|sha1|sha256|sha384|sha512>.  Default to 'sha1'
 -ip  <provider>     Issuer's CryptoAPI provider's name
 -iy  <type>         Issuer's CryptoAPI provider's type
 -sp  <provider>     Subject's CryptoAPI provider's name
 -sy  <type>         Subject's CryptoAPI provider's type
 -iky <keytype>      Issuer key type
                        <signature|exchange|<integer>>.
 -sky <keytype>      Subject key type
                        <signature|exchange|<integer>>.
 -l   <link>         Link to the policy information (such as a URL)
 -cy  <certType>     Certificate types
                        <end|authority>
 -b   <mm/dd/yyyy>   Start of the validity period; default to now.
 -m   <number>       The number of months for the cert validity period
 -e   <mm/dd/yyyy>   End of validity period; defaults to 2039
 -h   <number>       Max height of the tree below this cert
 -len <number>       Generated Key Length (Bits)
 -r                  Create a self signed certificate
 -nscp               Include Netscape client auth extension
 -crl                Generate a CRL instead of a certificate
 -eku <oid[<,oid>]>  Comma separated enhanced key usage OIDs
 -?                  Return a list of basic options
 -!                  Return a list of extended options
```



