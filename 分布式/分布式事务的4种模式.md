# 分布式事务的4种模式

常见的分布式事务解决方案

1. seata阿里分布式事务框架
2. 消息队列
3. saga
4. XA

它们有一个共同点，都是“两阶段”。“两阶段”是指完成整个分布式事务，划分成两个步骤完成。

实际上，这四种常见的分布式事务解决方案，分别对应这分布式事务的四种模式：AT、TCC、Saga、XA。

四种分布式事务模式，都有各自的理论基础，分别在不同的时间被提出；每种模式都有它的适用场景，同样每个模式也都有诞生各自的代表产品。

**分布式事务理论基础**

解决分布式事务，也有相应的规范和协议。分布式事务相关的协议有2PC、3PC。

由于三阶段提交协议3PC非常难实现，目前市面主流的分布式事务解决方案都是2PC协议。这就是文章开始提及常见的分布式事务解决方案里面，那些列举的都有一个共同点“两阶段”的内在原因。

**两阶段提交协议2PC**

两阶段提交协议：事务管理器分两个阶段来协调资源管理器，第一阶段准备资源，也就是预留事务所需的资源，如果每个资源管理器都预留资源成功，则进行第二阶段资源提交，否则协调资源管理器回滚资源。

2PC协议的核心是，划分出了事务参与者和协调者的角色，并将整个过程划分成两个阶段。

第一阶段：所有事务参与者，执行后进行与提交；直到协调者收到所有参与者的预提交才会进入第二阶段。

- 如果在协调者的超时时间内，有任意参与者的预提交preCommit没发送或未送达，都会结束事务。

第二阶段：所有事务预提交了各自的结果后，由协调者决定最终事务是成功（commit）还是失败（rollback）。

二阶段提交看起来确实能够提供原子性的操作，但是不幸的是，二阶段提交还是有几个缺点的：

1. 执行过程中，所有参与节点都是事物阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
2. 参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。
3. 协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。
4. 二阶段无法解决的问题：协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否已经被提交。

## 三阶段提交协议3PC

与两阶段提交不同的是，三阶段提交有两个改动点。

1. 引入超时机制。同时在协调者和参与者中都引入超时机制。
2. 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各个参与节点的状态都是一致的。

也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。

1. CanCommit阶段

   3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应。否则返回No响应。

   1. 事务询问协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者响应。
   2. 响应反馈，参与者接收到CanCommit请求之后，正常情况下，如果其自身认为可以顺利提交事务，则返回Yes，并进入预备状态，否则放回No。

2. PreCommit阶段

   协调者根据参与者的反应情况来决定是否可以继续事务的PreCommit操作。根据响应情况，有以下两种可能。假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。

   1. 发送预提交请求，协调者向参与者发送PreCommit请求，并进入Prepared阶段。
   2. 事务预提交，参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
   3. 响应反馈，如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

   假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接收到参与者的响应，那么就执行事务中断操作。

   1. 发送中断请求，协调者向所有参与者发送abort请求。
   2. 中断事务，参与者接收到来自协调者的abort请求之后（或者超时之后，仍未收到协调者的请求），执行事务中断操作。

3. DoCommit阶段

   该阶段进行真正的事物提交，也可以分为以下两种情况：

   1. 执行提交

      1. 发送提交请求，协调者接收到参与者发送的ACK响应，那么它将从预提交状态进入提交状态。并向所有参与者发送DoCommit请求。
      2. 事务提交，参与者接收到DoCommit请求之后，执行真正的事务提交。并在完成事务之后释放所有事务资源。
      3. 响应反馈，事务提交完之后，向协调者发送ACK响应。
      4. 完成事务，协调者接收到所有参与者的ACK响应之后，完成事务。

   2. 中断事务

      协调者没有接收到参与者发送的ACK响应（可能参与者发送的不是ACK响应，也可能响应超时），那么就会执行事务的中断操作。

      1. 发送中断请求，协调者向所有参与者发送abort请求。
      2. 事务回滚，参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事物资源。
      3. 反馈结果，参与者完成事务回滚之后，向协调者发送ACK消息。
      4. 中断事务，协调者接收到参与者反馈的ACK消息之后，执行事务的中断。

## 分布式事务实现



### AT模式

AT模式是一种无侵入的分布式事务解决方案。阿里Seata框架实现了该模式。

在AT模式下，用于只需要关注自己的“业务SQL”，用户的“业务SQL”作为一阶段，Seata框架会自动生成事务的二阶段提交和回滚操作。

![](1https://upload-images.jianshu.io/upload_images/9033085-8c114a81d8077830.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

AT模式如何做到对业务无侵入呢？

- 一阶段：

  在一阶段，Seata会拦截“业务SQL”，首先解析SQL语义，找到“业务SQL”要更新的业务数据，在业务数据被更新前，将保存成”before image“，然后执行”业务SQL“更新业务数据，在业务更新之后，再将其保存成"after image"，最后生成行锁。

  以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。

  ![](https://upload-images.jianshu.io/upload_images/9033085-d194316874308f4e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

- 二阶段提交：

  二阶段如果是提交的话，因为“业务SQL”在一阶段已经提交至数据库，所以Seata框架只需要将一阶段保存的快照数据和行锁删除，完成数据的清理即可。

  ![](https://upload-images.jianshu.io/upload_images/9033085-11f0248e4e6b4733.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

- 二阶段回滚：

  二阶段如果是回滚的话，Seata就需要回滚一阶段已经执行的“业务SQL”，还原业务数据。回滚方式便是用“before image”还原业务数据；但在还原前要首先校验脏写，对比“数据库当前业务数据”和“after image”，如果两份数据完全一致则说明没有脏写，可以还原业务数据，如果一致，就说明有脏写，出现脏写就需要人工处理。

  ![](https://upload-images.jianshu.io/upload_images/9033085-9e7c66807dead1f9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

  AT模式的一阶段、二阶段和回滚均由Seata框架自动生成，用户只需要编写“业务SQL”，便能轻松接入分布式事务。AT模式是一种对业务无任何侵入的分布式事务解决方案。

  ## TCC模式

  TCC模式需要用户根据自己的业务场景实现Try、Confirm和Cancel三个操作；事务发起方在一阶段执行Try操作，在二阶段提交执行Confirm操作，二阶段回滚执行Cancel操作。

  ![](https://upload-images.jianshu.io/upload_images/9033085-2ec2ac407f433bb4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

TCC三个操作说明：

- Try：资源的检测和预留。
- Confirm：执行业务操作的提交；要求Try成功，Confirm一定能成功。
- Cancel：预留资源释放。

TCC是实践经验

蚂蚁金服TCC实践总结有一下注意事项：

- 业务模型分2阶段设计。
- 并发控制。
- 允许空回滚
- 防悬挂控制
- 幂等控制

**TCC设计 - 业务模型分2阶段设计**

用户接入TCC，最重要的是考虑如何将自己的业务模型拆成两阶段来实现。

以“扣钱”场景为例，在接入TCC之前，对A账户扣钱，只需要一条更新账户余额的SQL便能完成。但是在接入TCC之后，用户就需要考虑如何将原来一步就能完成的扣钱操作，拆分成两阶段，实现成三个方法，并且保证一阶段Try成功的话二阶段Confirm一定能成功。

![](https://upload-images.jianshu.io/upload_images/9033085-e08b039930995fbf.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

如上图所示，Try方法作为一阶段准备方法，需要做资源的检查和预留。在扣钱场景下，Try要做的事情就是检查账户余额是否充足，预留转账资金，预留的方式就是冻结A账户下的转账资金。Try方法执行之后，账户A余额虽然还是100，但是其中30元已经被冻结了，不能被其他事务使用。

二阶段Confirm方法执行真正的扣钱操作。Confirm会使用Try阶段冻结的资金，执行账号扣款。Confirm方法执行之后，账号A在一阶段中冻结的30元已经被扣除，账号A余额变成70元。

如果二阶段是回滚的话，就需要在Cancel方法内释放一阶段Try冻结的30元，使账号A回到初始状态，100元全部可用。

用户接入TCC模式，最重要的事情就是考虑如何将业务模型拆分成2阶段，实现成TCC的3个方法，并且保证Try成功Confirm也一定成功。相对于AT模式，TCC模式对业务代码有一定的侵入性，但是TCC模式无AT模式的全局行锁，TCC性能会比AT模式高很多。

**TCC设计 - 允许空回滚**

![](https://upload-images.jianshu.io/upload_images/9033085-8e6889c42f172144.png?imageMogr2/auto-orient/strip|imageView2/2/w/1196/format/webp)





