# 快速排序

[TOC]

## 算法简介

快速排序（Quicksort）是对冒泡排序算法的一种改进。快速排序是一种**不稳定**的排序算法，即在排序过程中，相同值的元素的相对位置会发生变化。

## 算法原理

给定一个数组S，在其中任意选取一元素v，将数组中所有大于或等于v的元素放到v的右边，小于或等于v的元素放到v的左边。然后递归的将v左边和右边的子数组仍以此步骤操作，直到不可分割为止。最终就是排好序的数组，而这样的排序方式就是“经典快速排序”。

经典快速排序算法由下列简单的四步组成：

1. 如果S中的元素个数是0或1，则返回。
2. 取S中的任一元素v，称之为**枢纽元**。
3. 将`S - {v}`划分为两个不相交的集合：`S₁ = {x ∈ S - {v} | x ≥ v}`和`S₂ = {x ∈ S - {v} | x ≤ v}`
4. 以`S₁`和`S₂`为源数组，重复2,3步骤，每步返回{`quicksort(S₁)`后跟`v`，继而返回`quicksort(S₂)`}。

### 选取枢纽元

#### 首元素法

所谓首元素法就是将S的第一个元素作为枢纽元。而这是最无知的做法。如果S是随机的，那么这是可以接受的，而如果S是与排序或者反序的，那么这样的枢纽元将产生一个劣质的分割，因为所有的元素不是都被划入S₁，就是被划入S₂。更糟糕的是，这样的情况将发生在所有的递归调用当中，这将导致花费O(n²)的时间，可是实际上，什么事情都没有干。而且，在实践当中，预排序的情况是相当常见的。因此，选取第一个元素作为枢纽元绝对是不可取的。

#### 随机法

所谓随机法就是在S中随机的选取一个元素所谓枢纽元，一般来说这是一种安全的策略，因为随机选取的枢纽元不可能总是产生劣质的分割。但是，另一方面，随机数的生产一般开销很大，不能有效的减少算法其余部分的平均运行时间。

#### 三数中值分割法

三数中值分割法中的三数是指S的左端，右端，中心位置的三个元素，选取这三个元素的中值作为枢纽元。例如，{5，3，7，6，4，1，0，2，9，10，8}，它左边的元素是5，右边的元素是8，中心位置（`⌊(left+right)/2⌋`）的元素是1，于是枢纽元v=5。显然使用三数中值分割法消除了预排序的坏情形，并且实际减少了14%的比较次数。

### 分割策略

网络上大部分所讲解的快速排序都是采用的方式都是以首个元素作为枢纽元，先不论选取第一个元素作为枢纽元是否可取，其所采用的分割策略也不是最优的选择。为了更好的理解已被证明能够给出最好结果的分割策略，还是先介绍一下这种非最优分割策略的方式，以做对比。

**非最优分割策略**

设要排序的序列为A[0]~A[N-1]，首选从序列中选取第一个元素A[0]作为枢纽元v。将小于v的元素放到它的左边，大于A[0]的元素放到它的右边。

一趟快速排序算法的流程如下：

1. 定义两个指针i和j，分别指向i=0，j=N-1。
2. 以序列的第一个元素作为枢纽元（pivot），A[i]=pivot。
3. 首先从j开始向前搜索（由后向前，即j--），顺序查找到第一个小于pivot的元素A[j]，将A[j]与A[i]的值交换，此时分界值（pivot）等于A[j]。
4. 然后从i开始向后搜索（由前向后，即i++），顺序查找到第一个大于pivot的元素A[i]，将A[i]与A[j]的值交换，此时分界值（pivot）等于A[i]。
5. 在然后重复第3、4步，直到i==j为止。

不考虑枢纽元的选择，这种分割策略所带来的问题是，在指针i和j每发现一个比枢纽元大和小的元素时，都需要与枢纽元发生一次交换。下面将介绍的最优分割策略可以使其交换次数减少一一半。

**最优分割策略**

一趟快速排序算法的流程如下：

1. 采用三数中值分割法选取一个枢纽元。

2. 将枢纽源与最后的元素交换使得枢纽元离开要被分割的数据段。指针i从第一个元素开始，而指针j从倒数第二个元素开始。

   如下图所示：

3. 将i右移，移过那些小于枢纽元的元素，将j右移，移过那些大于枢纽元的元素。

4. 当i和j停止的时，i指向一个大于枢纽元而j指向一个小于枢纽元的元素，此时如果i在j的左边，则将i和j所指向的元素进行交换，其效果是把一个大的元素推向右边，把一个小的元素推向左边。

5. 重复第四步，直到i等于j，或者i在j的右边。此时i和j已经交错，故不再交换。

6. 将枢纽元与i所指向的元素交换。

> 当最后一步将枢纽元与i所指向的元素交换时，我们知道在位置p<i的每一个元素都必然是小元素，这是因为在位置p或者包含一个从它开始移动的小元素，或者位置p上原来的大元素在移动期间被置换了。类似的论断可以指出，在位置p>i上的都必然是大元素。因此，最后一步将枢纽元与i所指向的元素交换即可满足枢纽元左边的元素都小于它，右边的元素都大于它。

采用这种分割策略，其交换是将左边大于枢纽元和右边小于枢纽元的元素交换，一对大于枢纽元和小于枢纽元的元素只需要交换一次，而在*非最优分割策略*中需要交换两次，针对同一数列S，基本可以减少一半的交换次数。

### 相等元素处理

另外需要考虑的是如何处理哪些等于枢纽元的元素。问题在于当i遇到一个等于枢纽元的元素时是否应该停止，以及当j遇到一个等于枢纽元的元素时是否应该停止。直观的看，i和j应该做相同的工作，否则分割将出现偏向一方的倾向。例如i停止而j不停止，那么所有等于枢纽元的元素都将被分配到S₂中。

为了好的说明，我们考虑数组中所有元素都相等的情况：

如果i和j停止，那么在相等元素间将会有很多次交换，看起来这似乎没有什么意义，但其正面效果则是i和j将在中间被交换，因此当枢纽元被交换回来时，将建立两个几乎相等的子数组。归并排序的分析告诉我们，此时的运行时间为O(n log(n))。

如果i和j都不停止，那么i或j会一直移动到S的右端或左端，这样产生的效果与采用*首元素法*选取枢纽元所导致的问题是一样的，所有的元素不是都被划入S₁，就是被划入S₂。因此其时间复杂度为O(n²)。

如此看来，进行不必要的交换得到两个均衡的子数组比冒险蛮干得到两个不均衡的子数组要好。因此，如果i或j遇到与枢纽元相等的元素时，那么i和j就都停止。

### 小数组

对于很小的数组（N≤20），快速排序不如插入排序。因此对于小于的数组，不推荐使用递归的快速排序，而代之以诸如插入排序这样对小数组有效的排序算法。

## 算法示例

数列S：{5，3，7，6，4，1，0，2，9，10，8}

### 非最优分割策略示例

第一趟快速排序的流程如下图所示：

![](images/quick-sort-1.png)

将顺序表的第一个元素5作为pivot。

1. 首先从指针j开始向前查找，第一个小于5的元素的是2，将5于2交换。
2. 然后从指针i开始向后查找，第一个大于5的元素是7，将5于7交换。
3. 继续从指针j开始向前查找，第一个小于5的元素的是0，将5于0交换。
4. 继续从直接i开始向后查找，第一个大于5的元素是6，将5于6交换。
5. 继续从指针j开始向前查找，第一个小于5的元素的是1，将5于1交换。
6. 继续从直接i开始向后查找，到指针j之前，没有大于5的元素了。
7. 此时指针i和指针j重合，pivot左边的元素都小于它，右边的元素都大于它，第一趟快速排序完成。

依次类推，继续将5左边部分序列和右边部分序列以同样的原理分别进行快速排序，如下图所示：

![](images/quick-sort-2.png)

不同分界值的排序结果：

5 : [2, 3, 0, 1, 4, 5, 6, 7, 9, 10, 8]
2 : [1, 0, 2, 3, 4, 5, 6, 7, 9, 10, 8]
1 : [0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 8]
3 : [0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 8]
6 : [0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 8]
7 : [0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 8]
9 : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

### 最优分割策略示例



![](images/quick-sort-3.png)

![](images/quick-sort-4.png)

![](images/quick-sort-5.png)



## 算法实现

快速排序是一个递归的过程。其算法实现代码如下：

```java
public void quickSort(int[] arrays) {
    quickSort(arrays, 0, arrays.length - 1);
}

private void quickSort(int[] arrays, int s, int e) {
    int i = s, j = e, pivot = arrays[s];
    while (i < j) {
        while (j > i && arrays[j] >= pivot) j--;
        if (j != i) {
            arrays[i] = arrays[j];
            arrays[j] = pivot;
        }
        while (i < j && arrays[i] <= pivot) i++;
        if (i != j) {
            arrays[j] = arrays[i];
            arrays[i] = pivot;
        }
    }
    if (i > s + 1) quickSort(arrays, s, i - 1);
    if (i < e - 1) quickSort(arrays, i + 1, e);
}
```

## 算法分析

**时间复杂度**

快速排序的一次划分从两头交替搜索，直到low和hight重合，因此，每一趟快速排序的时间复杂度都是O(n)，因而整个快速排序算法的时间复杂度与需要排序的趟数有关。

最好的情况是，每次划分所选择的中间数恰好将序列几乎等分，经过`log₂ⁿ`趟，既可得到长度为1的子表，这样，整个算法的时间复杂度为`O(n*logn)`。

最坏的情况是，每次所选择的分界值是当前序列的中的最大或最小元素，这使得每次划分所得的子表中，一个为空表，另一个表的长度为原表的长度减1。这样，长度为n的序列的快速排序需要经过n趟划分，使得整个排序算法的时间复杂度为`O(n²)`。

为了改善最坏情况下的时间性能，可以采取“三者值取中”方法，即比较T[low]、T[high]和T[(low+high)/2]三个元素的大小，取中间那个作为分界值。

可以证明，快速排序的平均时间复杂度也是`O(n*logn)`。因此，快速排序算法是目前最好的一种**内部**排序算法。

**空间复杂度**

快速排序只需要一个元素的辅助空间。但是快速排序是一个递归操作，每一次递归都需要申请相应的栈空间。跟时间复杂度一样，最好的情况下，每一趟快排都将序列元素等分，因此所需栈的最大深度为O(log₂⁽ⁿ⁺¹⁾)；而最坏的情况下，栈的最大深度为O(n)。因此，快速排序的空间复杂度为O(log n)。

**稳定性**

快速排序是一种**不稳定**的内部排序算法。