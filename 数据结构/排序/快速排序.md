# 快速排序

[TOC]

## 算法简介

快速排序（Quicksort）是对冒泡排序算法的一种改进。

## 算法原理

设定一个分界值，通过该分界值将整个序列分成左右两部分。具体而言，就是将大于或等于分界值的元素放到分界值的右边，小于或等于分界值的元素放到分界值的左边。此时左边部分的所有元素都小于或等于分界值，右边部分的所有元素都大于或等于分界值。然后再继续分别对左右两个的序列各设定一个分界值再次对其进行左小右大的排列，重复此过程，一直到无法分割为止。可以看出，这是一个递归的过程，通过递归将左边的元素排好序，再通过递归将右边的元素排好序。当左右两边都排好之后，整个序列就有序了。

设要排序的序列为A[0]-A[N-1]，首选从序列中任意选取一个元素（通常选择第一个A[0]）作为分界值。将小于A[0]的元素放到它的左边，大于A[0]的元素放到它的右边，这个过程称为一趟快速排序。

快速排序是一种**不稳定**的排序算法，即在排序过程中，相同值的元素的相对位置会发生变化。

一趟快速排序算法的流程：

1. 定义两个指针i和j，分别指向i=0，j=N-1。
2. 以序列的第一个元素作为分界值（pivot），A[i]=pivot。
3. 首先从j开始向前搜索（由后向前，即j--），顺序查找到第一个小于pivot的元素A[j]，将A[j]与A[i]的值交换，此时分界值（pivot）等于A[j]。
4. 然后从i开始向后搜索（由前向后，即i++），顺序查找到第一个大于pivot的元素A[i]，将A[i]与A[j]的值交换，此时分界值（pivot）等于A[i]。
5. 在然后重复第3、4步，直到i==j为止。

## 算法示例

顺序表：{5，3，7，6，4，1，0，2，9，10，8}

第一趟快速排序的流程如下图所示：

![](images/quick-sort-1.png)

将顺序表的第一个元素5作为pivot。

1. 首先从指针j开始向前查找，第一个小于5的元素的是2，将5于2交换。
2. 然后从指针i开始向后查找，第一个大于5的元素是7，将5于7交换。
3. 继续从指针j开始向前查找，第一个小于5的元素的是0，将5于0交换。
4. 继续从直接i开始向后查找，第一个大于5的元素是6，将5于6交换。
5. 继续从指针j开始向前查找，第一个小于5的元素的是1，将5于1交换。
6. 继续从直接i开始向后查找，到指针j之前，没有大于5的元素了。
7. 此时指针i和指针j重合，pivot左边的元素都小于它，右边的元素都大于它，第一趟快速排序完成。

依次类推，继续将5左边部分序列和右边部分序列以同样的原理分别进行快速排序，如下图所示：

![](images/quick-sort-2.png)

不同分界值的排序结果：

5 : [2, 3, 0, 1, 4, 5, 6, 7, 9, 10, 8]
2 : [1, 0, 2, 3, 4, 5, 6, 7, 9, 10, 8]
1 : [0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 8]
3 : [0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 8]
6 : [0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 8]
7 : [0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 8]
9 : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

## 算法实现

快速排序是一个递归的过程。其算法实现代码如下：

```java
public void quickSort(int[] arrays) {
    quickSort(arrays, 0, arrays.length - 1);
}

private void quickSort(int[] arrays, int s, int e) {
    int i = s, j = e, pivot = arrays[s];
    while (i < j) {
        while (j > i && arrays[j] >= pivot) j--;
        if (j != i) {
            arrays[i] = arrays[j];
            arrays[j] = pivot;
        }
        while (i < j && arrays[i] <= pivot) i++;
        if (i != j) {
            arrays[j] = arrays[i];
            arrays[i] = pivot;
        }
    }
    if (i > s + 1) quickSort(arrays, s, i - 1);
    if (i < e - 1) quickSort(arrays, i + 1, e);
}
```

## 算法分析

**时间复杂度**

快速排序的一次划分从两头交替搜索，直到low和hight重合，因此，每一趟快速排序的时间复杂度都是O(n)，因而整个快速排序算法的时间复杂度与需要排序的趟数有关。

最好的情况是，每次划分所选择的中间数恰好将序列几乎等分，经过`log₂ⁿ`趟，既可得到长度为1的子表，这样，整个算法的时间复杂度为`O(n*logn)`。

最坏的情况是，每次所选择的分界值是当前序列的中的最大或最小元素，这使得每次划分所得的子表中，一个为空表，另一个表的长度为原表的长度减1。这样，长度为n的序列的快速排序需要经过n趟划分，使得整个排序算法的时间复杂度为`O(n²)`。

为了改善最坏情况下的时间性能，可以采取“三者值取中”方法，即比较T[low]、T[high]和T[(low+high)/2]三个元素的大小，取中间那个作为分界值。

可以证明，快速排序的平均时间复杂度也是`O(n*logn)`。因此，快速排序算法是目前最好的一种**内部**排序算法。

**空间复杂度**

快速排序只需要一个元素的辅助空间。但是快速排序是一个递归操作，每一次递归都需要申请相应的栈空间。跟时间复杂度一样，最好的情况下，每一趟快排都将序列元素等分，因此所需栈的最大深度为O(log₂⁽ⁿ⁺¹⁾)；而最坏的情况下，栈的最大深度为O(n)。因此，快速排序的空间复杂度为O(log n)。

**稳定性**

快速排序是一种**不稳定**的内部排序算法。