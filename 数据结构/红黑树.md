# 红黑树

在阅读前我们假设您已经完全理解AVL树，因为红黑树的旋转操作我们已经省去了具体的操作。如果没有完全理解AVL树，可以参阅文章[AVL](数据结构/AVL.md)。

## 简介

红黑树是实际应用中最常用的二叉平衡查找树，它不严格的具有平衡属性，但是，平均的使用性能却非常良好。在红黑树当中，节点被标记为红色和黑色两种颜色，并且它还具有下面的这三个性质：

1. 根节点是黑色的，每个页节点都是不存储数据的黑色空节点。
2. 任何相邻的两个节点都不能同时为红色，即红色节点被黑色节点隔开。红色节点的孩子节点是黑色的。
3. 树中的任意节点到齐可到达的叶节点之间都包含了相同数量的黑色节点。



没有一条路径比其他路径长出2倍，树的高度稳定趋近与$log^n$，从而在树上的各种操作也就是$log^n$。实际上，一棵有n个节点的红黑树的高度最多是$2log^{n+1}$。

证明

首先我们将红黑树中的红色节点删除，并且将红色节点的子节点与它的父节点相连，这样就得到了最多有四条分支的树，我们知道，树中的任意节点到齐可到达的叶节点之间都包含了相同数量的黑色节点，这就说明了删掉红色节点得到的树每个节点到叶节点的路径长度都是相同的，是一棵最多有四条分支的完全四叉树。一个具有n个节点的完全二叉树高度最多时logn，而删除红色节点的树其他还要比它更矮一些，而算上空的叶节点，这样的黑色树的高度也不会超过logn+1，这个时候，我们将红色节点添加回去，就恢复成了红黑树，在红黑树当中，红色节点被黑色节点隔开，红色节点的子节点一定是黑色节点，所以每出现一个红色节点，就至少有一个黑色节点与它是对应的，由于刚刚证明了，只有黑色节点的路径最长不超过logn+1，即使这条路径上的每个黑色节点都对应一个红色节点，那么路径的长度也不会超过2倍的logn+1，所以，一个有n个结点的红黑树的高度最多是2倍的logn+1，那么对比AVL严格的平衡二叉树，其查找效率一定不超过logn，红黑树可能没有它查找的效率高，但是由于AVL为了保持严格的平衡，需要在每次插入和删除都做复杂的调整，而红黑树的插入和删除就简单的多，对于有频繁插入和删除操作的数据集合，显然，红黑树更有优势。而综合来说，红黑树的插入删除查找等各项操作的性能都更加稳定，所以在很多的实际应用当中，都会选择红黑树作为查找和存储的数据结构

## 优势





## 性质

红黑树具有如下性质：

1. 每一个节点或者是红色，或者是黑色。
2. 根节点是黑色的。
3. 每个叶节点都是不存储数据的黑色空节点。
4. 如果一个节点是红色的，那么其子节点必须是黑色（从根到每个叶子节点的路径上都不能有两个连续的红色节点）。
5. 从树中的任意节点到其可到达叶节点的路径上必须包含相同数量的黑色节点。

下图是一个标准的红黑树：

![](images\R-B-0.png)

插入顺序是：10,85,15,70,20,60,30,50,65,80,90,40,5,55

## 插入

对于红黑树的操作，通常困难在于如何将一个新节点插入到树中，一般是把新节点作为树叶放到树中。在插入新节点时，如果将该新节点标记成黑色，那么将违反约束⑤，因为在插入之前任意路径上的黑节点数量都相同，再新插入一个黑节点，将会使该路径上的黑色节点数量与其他路径不同。因此，插入的新节点必须被标记为红色。如果新节点的父节点是黑色，则插入完成（没有违反约束）。如果新节点的父节点是红色，就得到了连续的红色节点，违反了约束④。这这种情况下，需要通过改变其节点颜色和树的旋转来满足约束④，同时由不引起约束⑤破坏。

### 自底向上插入

#### 新插入项的父节点是黑色

**如果新插入项的父节点是黑色，那么插入完成。**因为这并不会违反红黑树的性质。例如插入元素25是简单操作（省略了节点30及其右子树）：

![](images\R-B-00.png)

#### 新插入项的父节点是红色

如果新插入项的父节点是红色，那么有两种情形需要考虑：

1. 父节点的兄弟节点是黑色
2. 父节点的兄弟节点是红色

---

令X是新添加的树叶，P是它的父节点，S是该父节点的兄弟节点（若存在），G是祖父节点。如下图所示：

![](images\R-B-1.png)

在这种情形下，只有X和P是红色，G是黑色的，否则就会在插入前有两个相连的红色节点（当前分析的是新插入项的父节点是红色，即预设了P是红色，X作为新插入节点，也是红色），违反了红黑树的约束④。

<font>父节点的兄弟节点是黑色</font>

如果父节点的兄弟节点是黑色，那么只需要旋转变色即可。

如下图所示，P是一个左儿子，对于X而言，分两种情况，一种是X作为P的左儿子，另一种是作为X作为P的右儿子。

![](images\R-B-2.png)

X作为P的左儿子：首先以P为中心向右旋转，然后将P变为黑色，G变为红色。

![](images\R-B-3.png)

X作为P的右儿子：首先以P为中心向左旋转，然后在以X为中心向右旋转，最后将X变为黑色，G变为红色。

![](images\R-B-4.png)

<font>父节点的兄弟节点是红色</font>

![](images\R-B-5.png)

同样需要区分X作为P的左儿子和X作为P的右儿子的情况。与父节点的兄弟节点是黑色的操作方式是一样的，不同的是，还需要考虑上滤的问题。

X作为P的左儿子：首先以P为中心向右旋转，然后将X变为黑色。

![](images\R-B-6.png)

X作为P的右儿子：首先以P为中心向左旋转，然后在以X为中心向右旋转，最后将P变为黑色。

![](images\R-B-7.png)

通过上面的旋转和变色发现，子树的根变为红色，如果曾祖父也是红色怎么办？如下图所示，变色之后，X的父节点C也是红色。此破坏了红黑树的性质④。

![](images\R-B-8.png)

解决这个问题的办法就是将这个过程朝着根的方向上滤。由于C是红色，那么它的父节点N一定是黑色。以C为中心向右旋转，然后将C变为黑色，N变为红色。

![](images\R-B-9.png)

### 自顶向下红黑树

其实对于父节点的兄弟节点是红色这种情况可以简化的，没有必要进行旋转。如下图所示：

![](images\R-B-10.png)

直接将节点P和S变成黑色，G变成红色即可。这样的操作是等价的。

原理虽然很简单，但是在程序的实际操作中却还是有些差异，在常规的理解中，是先将插入项X插入到树中之后再来判断是否需要旋转和变色。实际上，针对父节点的兄弟节点是红色的情况，采用自顶向下的过程会更有效，即在向下的过程中如果看到一个节点G有两个红色的子节点，可以将G转换成红色，其两个子节点转换成黑色。当G的父节点C也是红色时，这种翻转将破坏红黑树的性质，此时可以应用旋转和变色策略。通过这种方式，可以保证，在插入节点X时，其父节点的兄弟节点一定是黑色，因为这种可能已经被自顶向下的过程所排除。

此时，插入节点X，由于其父节点P是黑色，因此可以直接将X插入完成。

![](images\R-B-11.png)

## 算法分析



## 算法实现



## 参考资料

[算法导引-24-红黑树](https://www.bilibili.com/video/BV1w3411h74i?spm_id_from=333.337.search-card.all.click&vd_source=c2643806c515146154d63b396daf06eb)



