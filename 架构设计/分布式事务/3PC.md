# 3PC

3PC协议又称**三阶段提交协议**，是在2PC协议的基础上改进的版本，主要解决了2PC的同步阻塞和单点故障问题。3PC将2PC协议中的Prepare阶段一分为二，最终形成三个阶段：CanCommit，PreCommit和DoCommit阶段或DoRollback阶段。

- **CanCommit**：主要的工作是预留资源。

  例如从A账户向B账户转账，此阶段仅仅是将money从A账户扣除，而未向B账户转账。从A账户扣除的money存储在一张中间表T中作为预留的资源。

- **PreCommit**：主要的工作就是使用预留的资源。

  例如从中间表T中移除预留的资源，并向B账户增加money。注意，此阶段仅仅是基于本地事务执行了业务操作，而没有真正的提交事务。当这些工作都完成之后，阻塞，等待三阶段的消息。

- **DoCommit**：主要的工作就是真正提交事务。

  协调者向各参与者发送DoCommit消息，而各参与者提交本地事务。或者协调者向各参与者发送DoRollback消息，而各参与者回滚本地事务。

*3PC协议模型：*

![3PC](images\3PC.jpg)

**流程**

- 在CanCommit阶段，协调者向参与者发送CanCommit消息，参与者收到CanCommit消息后如果认为能够执行事务，则向协调者返回Yes，否则，返回No。
- 在PreCommit阶段，如果协调者收到所有的参与者都返回Yes，则向参与者发送PreCommit消息，如果至少有一个参与者响应No，则向参与者发送Abort消息。
- 在DoCommit阶段，协调者根据PreCommit阶段的结果向参与者发起DoCommit或DoRollback消息。

## 重要

- CanCommit阶段是**非阻塞**的。
- 对于参与者来说，只有接收到协调者的PreCommit消息时才会进入到PreCommit阶段。
- 如果协调者在PreCommit阶段向参与者发送的是PreCommit消息，那么参与者将会使用预留资源并阻塞，如果发送的是Abort消息，则回滚。
- 在DoCommit阶段，参与者可以不用等到（超时）协调者的DoCommit消息就可以自动提交。

## 超时机制

- CanCommit阶段，协调者增加了超时机制

  如果协调者长时间没有收到参与者的响应（超时），将认为参与者不能够执行事务，触发回滚操作。

- PreCommit阶段，参与者增加了超时机制

  如果参与者长时间没有收到协调者的DoCommit消息（超时），参与者将自动提交。

## 2PC与3PC

3PC是如何解决2PC的同步阻塞问题和单点故障问题的呢？

回顾一下2PC的问题，在执行Commit阶段之前，如果协调者挂了（单点故障），参与者就会一直阻塞在哪儿。而且也不能给参与者添加超时机制呢，因为参与者不知道此时是该提交还是该回滚。例如有部分参与者收到了消息，协调者才挂，或者协调者没挂，但是与其中部分参与者网络通信故障。假设设置了超时机制为超时回滚，但是成功与协调者通信的参与者收到的消息是Commit，那么超时回滚与正常提交的参与者之间数据就会不一致，反过来也是同样的道理。而这就是不能给参与者设置超时机制的原因。

3PC增加了PreCommit阶段，这个阶段等价于2PC的Prepare阶段。同样是：执行本地事务→告知协调者准备OK→阻塞等待，不同的是3PC的PreCommit阶段参与者知道自己该干啥 —— 超时提交。而这就是3PC能够超时提交的原因，同时也就解决了单点故障和同步阻塞的问题。

**如何知道**

对于参与者而言，如果在PreCommit阶段收到的是PreCommit消息，那么我（参与者）就知道其他参与者收到的消息一定也是PreCommit消息，因为在CanCommit阶段大家都已经达成一致了。如果我收到的是PreCommit消息，那就意味着在CanCommit阶段，所有的参与者都响应的是OK，因为只有所有的参与者都响应OK，协调者才会发送PreCommit消息。所以如果我长时间没有收到协调者的DoCommit消息，那我就自动提交了，因为其他参与者也这么做的。

而2PC呢，我（参与者）仅仅是在Prepare阶段向协调者响应了我OK，但是我不知道其他参与者O不OK，协调者也没有告诉我，所以我也就不知道该提交还是该回滚。

## 解决同步阻塞和单点故障

3PC的CanCommit阶段不会阻塞，因为它只是预留资源，预留成功就成功，预留失败就失败，如果这个过程当中无法与协调者通信（宕机或者网络异常），协调者就认为它不能执行事务（可能真失败，也可能假失败 - 网络超时，但实际上参与者预留成功了）。不管如何，对于协调者而言，它只会有两种结果，要么全部成功，要么有部分失败（真失败，或异常），此时状态明确的。因而，对于PreCommit阶段，要么就是PreCommit，要么就是Abort，没有二义性。

**CanCommit - YES**

如果所有的参与者都在CanCommit阶段响应YES，协调者将向参与者发送PreCommit消息。此时协调者宕机了，分三种情况：

1. 向所有参与者发送之前宕机

   由于所有的参与者都没有收到PreCommit消息，而且CanCommit阶段非阻塞，所以此时不会有任何阻塞的情况发生，也不会有数据不一致的问题。

2. 向部分参与者发送之后宕机

   对于部分收到PreCommit消息的参与者，将会超时提交，而没有收到PreCommit消息的参与者，不会阻塞。此时数据可能会有短暂的不一致，因为需要等待新的协调者被选出。

3. 向所有参与者发送之后宕机

   大家都超时提交，不会阻塞，不会数据不一致。

**CanCommit - NO**

如果有参与者在CanCommit阶段响应NO，协调者将向参与者发送Abort消息。此时协调者宕机了，分三种情况：

1. 向所有参与者发送之前宕机

   由于所有的参与者都没有收到Abort消息，而且CanCommit阶段非阻塞，所以此时不会有任何阻塞的情况发生，也不会有数据不一致的问题。

2. 向部分参与者发送之后宕机

   对于部分收到Abort消息的参与者，就直接回滚了（释放预留资源），而没有收到Abort消息的参与者，不会阻塞，也不会有数据不一致的问题。

3. 向所有参与者发送之后宕机

   大家都直接回滚了。

可以看到，无论在什么情况下协调者宕机，都不会产生阻塞问题，自然也就不存在单间故障问题。不过需要注意的是，如果协调者宕机，我们为其添加了选举机制，一旦新的协调者被选举出来，就继续工作。

## PreCommit异常

3PC并不是完整的，它也会引起数据不一致，问题就在于参与者PreCommit失败。

如果所有参与者都PreCommit成功，并及时响应给协调者，协调者就通知所有参与者DoCommit。如果有一个参与者在CanCommit阶段说行，而又在PreCommit阶段说："啊，我又不行了"，那么协调者就需要**及时**的通知其他参与者："快，有人不行了，快回滚"。问题就出在及时，如果不及时呢？假设有参与者PreCommit失败，并且协调者也收到了消息，然后向其他参与者发送DoRollback消息，但是在此时，由于网络异常，无法与某一个正常的参与者通信，该参与者就会超时提交，此时就产生数据不一致。

最后一个问题与2PC一样。即使不考虑网络问题，DoCommit阶段也并不一定是成功，如果有部分参与者提交失败，或者在提交之前宕机，就意味着该参与者的本地事务被回滚了，但是预留的资源没有释放。而其他参与者提交成功了。此时数据不一致。对于这个问题，理论上认为**PreCommit成功，DoCommit就一定成功**。

**总结**

3PC是一个理论上的分布式事务协议，虽然解决了部分2PC的问题，但是其数据的不一致问题仍然存在，并且相对2PC而言增加了一个阶段，其落地的复杂性就大大增加。因此3PC仅仅存在于理论阶段，目前没有对3PC的实现。