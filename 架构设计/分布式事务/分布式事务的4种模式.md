# 分布式事务的4种模式

常见的分布式事务解决方案

1. seata阿里分布式事务框架
2. 消息队列
3. saga
4. XA

它们有一个共同点，都是“两阶段”。“两阶段”是指完成整个分布式事务，划分成两个步骤完成。

实际上，这四种常见的分布式事务解决方案，分别对应这分布式事务的四种模式：AT、TCC、Saga、XA。

四种分布式事务模式，都有各自的理论基础，分别在不同的时间被提出；每种模式都有它的适用场景，同样每个模式也都有诞生各自的代表产品。

**分布式事务理论基础**

解决分布式事务，也有相应的规范和协议。分布式事务相关的协议有2PC、3PC。

由于三阶段提交协议3PC非常难实现，目前市面主流的分布式事务解决方案都是2PC协议。这就是文章开始提及常见的分布式事务解决方案里面，那些列举的都有一个共同点“两阶段”的内在原因。

## 两阶段提交协议2PC

两阶段提交协议：事务管理器分两个阶段来协调资源管理器，第一阶段准备资源，也就是预留事务所需的资源，如果每个资源管理器都预留资源成功，则进行第二阶段资源提交，否则协调资源管理器回滚资源。

2PC协议的核心是，划分出了事务参与者和协调者的角色，并将整个过程划分成两个阶段。

第一阶段：所有事务参与者，执行后进行与提交；直到协调者收到所有参与者的预提交才会进入第二阶段。

- 如果在协调者的超时时间内，有任意参与者的预提交preCommit没发送或未送达，都会结束事务。

第二阶段：所有事务预提交了各自的结果后，由协调者决定最终事务是成功（commit）还是失败（rollback）。

二阶段提交看起来确实能够提供原子性的操作，但是不幸的是，二阶段提交还是有几个缺点的：

1. 执行过程中，所有参与节点都是事物阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
2. 参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。
3. 协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。
4. 二阶段无法解决的问题：协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否已经被提交。

## 三阶段提交协议3PC

与两阶段提交不同的是，三阶段提交有两个改动点。

1. 引入超时机制。同时在协调者和参与者中都引入超时机制。
2. 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各个参与节点的状态都是一致的。

也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。

1. CanCommit阶段

   3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应。否则返回No响应。

   1. 事务询问协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者响应。
   2. 响应反馈，参与者接收到CanCommit请求之后，正常情况下，如果其自身认为可以顺利提交事务，则返回Yes，并进入预备状态，否则放回No。

2. PreCommit阶段

   协调者根据参与者的反应情况来决定是否可以继续事务的PreCommit操作。根据响应情况，有以下两种可能。假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。

   1. 发送预提交请求，协调者向参与者发送PreCommit请求，并进入Prepared阶段。
   2. 事务预提交，参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
   3. 响应反馈，如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

   假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接收到参与者的响应，那么就执行事务中断操作。

   1. 发送中断请求，协调者向所有参与者发送abort请求。
   2. 中断事务，参与者接收到来自协调者的abort请求之后（或者超时之后，仍未收到协调者的请求），执行事务中断操作。

3. DoCommit阶段

   该阶段进行真正的事物提交，也可以分为以下两种情况：

   1. 执行提交

      1. 发送提交请求，协调者接收到参与者发送的ACK响应，那么它将从预提交状态进入提交状态。并向所有参与者发送DoCommit请求。
      2. 事务提交，参与者接收到DoCommit请求之后，执行真正的事务提交。并在完成事务之后释放所有事务资源。
      3. 响应反馈，事务提交完之后，向协调者发送ACK响应。
      4. 完成事务，协调者接收到所有参与者的ACK响应之后，完成事务。

   2. 中断事务

      协调者没有接收到参与者发送的ACK响应（可能参与者发送的不是ACK响应，也可能响应超时），那么就会执行事务的中断操作。

      1. 发送中断请求，协调者向所有参与者发送abort请求。
      2. 事务回滚，参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事物资源。
      3. 反馈结果，参与者完成事务回滚之后，向协调者发送ACK消息。
      4. 中断事务，协调者接收到参与者反馈的ACK消息之后，执行事务的中断。

## 分布式事务实现



### AT模式

AT模式是一种无侵入的分布式事务解决方案。阿里Seata框架实现了该模式。

在AT模式下，用于只需要关注自己的“业务SQL”，用户的“业务SQL”作为一阶段，Seata框架会自动生成事务的二阶段提交和回滚操作。

![](https://upload-images.jianshu.io/upload_images/9033085-8c114a81d8077830.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

AT模式如何做到对业务无侵入呢？

- 一阶段：

  在一阶段，Seata会拦截“业务SQL”，首先解析SQL语义，找到“业务SQL”要更新的业务数据，在业务数据被更新前，将保存成”before image“，然后执行”业务SQL“更新业务数据，在业务更新之后，再将其保存成"after image"，最后生成行锁。

  以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。

  ![](https://upload-images.jianshu.io/upload_images/9033085-d194316874308f4e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

- 二阶段提交：

  二阶段如果是提交的话，因为“业务SQL”在一阶段已经提交至数据库，所以Seata框架只需要将一阶段保存的快照数据和行锁删除，完成数据的清理即可。

  ![](https://upload-images.jianshu.io/upload_images/9033085-11f0248e4e6b4733.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

- 二阶段回滚：

  二阶段如果是回滚的话，Seata就需要回滚一阶段已经执行的“业务SQL”，还原业务数据。回滚方式便是用“before image”还原业务数据；但在还原前要首先校验脏写，对比“数据库当前业务数据”和“after image”，如果两份数据完全一致则说明没有脏写，可以还原业务数据，如果一致，就说明有脏写，出现脏写就需要人工处理。

  ![](https://upload-images.jianshu.io/upload_images/9033085-9e7c66807dead1f9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

  AT模式的一阶段、二阶段和回滚均由Seata框架自动生成，用户只需要编写“业务SQL”，便能轻松接入分布式事务。AT模式是一种对业务无任何侵入的分布式事务解决方案。


### TCC模式

TCC模式需要用户根据自己的业务场景实现Try、Confirm和Cancel三个操作；事务发起方在一阶段执行Try操作，在二阶段提交执行Confirm操作，二阶段回滚执行Cancel操作。

![](https://upload-images.jianshu.io/upload_images/9033085-2ec2ac407f433bb4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

TCC三个操作说明：

- Try：资源的检测和预留。
- Confirm：执行业务操作的提交；要求Try成功，Confirm一定能成功。
- Cancel：预留资源释放。

TCC是实践经验

蚂蚁金服TCC实践总结有一下注意事项：

- 业务模型分2阶段设计。
- 并发控制。
- 允许空回滚
- 防悬挂控制
- 幂等控制

#### TCC设计 - 业务模型分2阶段设计

用户接入TCC，最重要的是考虑如何将自己的业务模型拆成两阶段来实现。

以“扣钱”场景为例，在接入TCC之前，对A账户扣钱，只需要一条更新账户余额的SQL便能完成。但是在接入TCC之后，用户就需要考虑如何将原来一步就能完成的扣钱操作，拆分成两阶段，实现成三个方法，并且保证一阶段Try成功的话二阶段Confirm一定能成功。

![](https://upload-images.jianshu.io/upload_images/9033085-e08b039930995fbf.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

如上图所示，Try方法作为一阶段准备方法，需要做资源的检查和预留。在扣钱场景下，Try要做的事情就是检查账户余额是否充足，预留转账资金，预留的方式就是冻结A账户下的转账资金。Try方法执行之后，账户A余额虽然还是100，但是其中30元已经被冻结了，不能被其他事务使用。

二阶段Confirm方法执行真正的扣钱操作。Confirm会使用Try阶段冻结的资金，执行账号扣款。Confirm方法执行之后，账号A在一阶段中冻结的30元已经被扣除，账号A余额变成70元。

如果二阶段是回滚的话，就需要在Cancel方法内释放一阶段Try冻结的30元，使账号A回到初始状态，100元全部可用。

用户接入TCC模式，最重要的事情就是考虑如何将业务模型拆分成2阶段，实现成TCC的3个方法，并且保证Try成功Confirm也一定成功。相对于AT模式，TCC模式对业务代码有一定的侵入性，但是TCC模式无AT模式的全局行锁，TCC性能会比AT模式高很多。

#### TCC设计 - 允许空回滚

![](https://upload-images.jianshu.io/upload_images/9033085-8e6889c42f172144.png?imageMogr2/auto-orient/strip|imageView2/2/w/1196/format/webp)

Cancel接口设计时需要允许空回滚。在Try接口因为丢包时没有收到，事务管理会触发回滚，这时会触发Cancel接口，这时Cancel执行时发现没有对应的事务xid或主键时，需要返回回滚成功。让事务服务管理器认为已经回滚，否则会不断重试。而Cancel又没有对应的业务数据可以进行回滚。

#### TCC设计 - 防悬挂控制

![](https://upload-images.jianshu.io/upload_images/9033085-339dca209f9fcd1d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

悬挂的意思是：Cancel比Try接口先执行，出现的原因是Try由于网络拥堵而超时，事务管理器生成回滚，触发Cancel接口，最终又收到了Try接口调用，但是Cancel比Try先到。按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已经会成功，则此时的Try接口不应该执行，否则会产生数据不一致，所以我们在Cancel空回滚成功之前先记录该条事务xid或业务主键，标识这条记录以及回滚过，Try接口先检查这条事务xid或业务主键，如果已经标记为回滚成功过，则不执行Try的业务操作。

#### TCC设计 - 幂等控制

![](https://upload-images.jianshu.io/upload_images/9033085-33bd5611afa7b622.png?imageMogr2/auto-orient/strip|imageView2/2/w/1198)

幂等性的意思是：对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。因为网络抖动或拥堵可能会超时，事务管理器会对资源进行重试操作，所以很可能一个业务操作会被重复调用，为了不因为重复调用而多次占用资源，需要对服务设计时进行幂等控制，通常我们可以用事务xid或业务主键判重来控制。

## Saga模式

![](https://upload-images.jianshu.io/upload_images/9033085-b37a70c027f775d0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

Saga理论出自Hector & Kenneth 1987发表的论文Sagas。

Saga模式的实现，是长事务解决方案。

Saga是一种补偿协议，在Saga模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。

![](https://upload-images.jianshu.io/upload_images/9033085-0e012b38cf5ae2d1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

分布式事务执行过程中，**依次执行**各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会退回去执行前面各个参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。

Saga正向服务与补偿服务也需要业务开发者实现。因此是**业务侵入的**。

Saga模式下分布式事务通常是**由事件驱动**的，**各个参与者之间是异步的**，Saga模式是一种**长事务解决方案**。

**Saga模式使用场景**

Saga模式适用于业务流程长且需要保证事务最终一致性的业务系统，Saga模式一阶段就会提交本地事务，无锁，长流程的情况下可以保证性能。

事务参与者可能是其他公司的服务或者遗留系统的服务，无法进行改造和提供TCC要求的接口，可以使用Saga模式。

**Saga模式的优势**

优点：

- 一阶段提交本地数据库事务，无锁，高性能。
- 参与者可以采用事务驱动异步执行，高吞吐。
- 补偿服务即正向服务的“反向”，易于理解，易于实现。

缺点：

Saga模式由于一阶段已经提交本地数据库事务，且没有进行“预留”动作，所以不能保证隔离性。后续会讲到对于缺乏隔离性的应对措施。

于TCC实践经验相同的是，Saga模式中，每个事务参与者的冲正，逆向操作，需要支持：

- 空补偿：
- 防悬挂控制：
- 幂等

## XA模式

XA是X/Open DTP组织（X/Open DTP group）定义的两阶段提交协议，XA被许多数据库（Oracle、DB2、SQL Server、MySQL）和中间件等工具（如CICS和Tuxedo）本地支持。

X/Open DTP模型（1994）包括应用程序（AP）、事务管理器（TM）、资源管理器（PM）。

XA接口函数由数据库厂商提供。

JTA（Java Transaction API）是Java实现的XA规范的增强版接口。

在XA模式下，需要有一个[全局]协调器，每一个数据库事务完成后，进行第一阶段预提交，并通知协调器，把结果给协调器。协调器等所有分支事务操作完成、都预提交后，进行第二步。第二步：协调器通知每个数据库进行逐个commit/rollback。

其中，这个全局协调器就是XA模式中的TM角色，每个分支事务各自的数据库就是RM。

MySQL提供的XA实现（https://dev.mysql.com/doc/refman/5.7/en/xa.html）

XA模式下的开源框架有atomikos，其开发公司也有商业版本。

XA模式缺点：事务粒度大。高并发下，系统可用性低。因此很少使用。

## （AT、TCC、Saga、XA）模式分析

四种分布式事务模式，分别在不同的时间被提出，每种模式都有它的适用场景

- AT模式是无侵入的分布式事务解决方案，适用于不希望对业务进行改造的场景，几乎0学习成本。
- TCC模式是高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景。
- Sage模式是长事务解决方案，适用于业务流程长，且需要保证事务最终一致性的业务系统。Saga模式一阶段就会提交本地事务，无锁，长流程情况下可以保证性能，多用于渠道层、集成层业务系统。事务参与者可能其他公司的服务或者遗留系统的服务，无法进行改造和提供TCC要求的接口，也可以使用Saga模式。
- XA模式是分布式强一致性的解决方案，但性能低而使用较少。

## RocketMQ实现可靠消息最终一致性

- 可靠消息最终一致性就是保住消息从生产方经过消息中间件传递到消费方的一致性。
- RocketMQ主要解决了两个功能：本地事务与消息发送的原子性问题。事务参与方接收消息的可靠性。
- 可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景，引入消息机制后，同步的事物操作变为基于消息执行的异步操作，避免分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yLzE2ZWM1YmY0MGM3ZThiYjQ?x-oss-process=image/format,png)

## 最大努力通知

最大努力通知与可靠消息一致性有什么不同

- 可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发送到接收通知方，消息的可靠性由发起通知方保证。
- 最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是消息可能接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务，通知可靠性关键在于接收通知方。

两者的应用场景

- 可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易。
- 最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去。

基于MQ的ack机制实现最大努力通知

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yLzE2ZWM1YmY0MGNlZTFmMGQ?x-oss-process=image/format,png)

- 利用MQ的ack机制由MQ向接收通知方发送消息通知，发起方将普通消息发送到MQ。
- 接收通知监听MQ，接收消息，业务处理完成回应ACK。
- 接收通知方如果没有回应ACK则MQ会重复通知，按照时间间隔的方式，逐步拉大通知间隔。
- 此方案适用于内部微服务之间的通知，不适应与外部平台通知。

方案二：增加一个通知服务区进行通知，提供外部第三方时适用

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yLzE2ZWM1YmY0MGQwNWFkZTM?x-oss-process=image/format,png)

## 分布式事务方案对比分析

- 2PC最大的一个诟病是一个阻塞协议。RM在执行分支事务后需要等待TM的决定，此时服务会阻塞锁定资源。由于其阻塞机制和最差时间复杂度，因此，这种设计不能适应随着事务涉及的服务数量增加而扩展的需要，很难用于并发较高以及子事务生周期较长的分布式服务中。
- 如果拿TCC事务的处理流程与2PC两阶段提交做比较，2PC通常都是在跨库的DB层面，而TCC则在应用层面处理，需要通过业务逻辑来实现。这种分布式事务的优势在于，可以让应用自定义数据库操作的粒度，使得降低锁冲突，提高吞吐量称为可能。而不足之处在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现三个操作，此外，其实现难度也比较大，需要按照网络状态，系统故障等不同失败原因实现不同的策略。
- 可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消息执行的异步操作，避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。典型的场景：注册送积分，登录送优惠券等。
- 最大努力通知是分布式事务中要求最低的一种，适用于一些最终一致性时间敏感度低的业务，允许发起通知方业务处理失败，在接收通知方接收到通知后积极进行失败处理，无论发起通知方如何处理结果都不会影响到接收通知方的后序处理，发起通知方需要提供查询执行情况接口，用于接收通知方校对结果。典型的应用场景：银行通知，支付结果通知等。

2PC、TCC、可靠消息、最大努力通知

![](http://img.blog.itpub.net/blog/2019/12/30/830db1a8b8a0e76c.png?x-oss-process=style/bb)







吞吐量，低延迟