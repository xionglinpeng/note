# 分布式缓存一致性

在高并发的系统中，为了提升服务效率，常常会引入缓存银弹。缓存有各种各样的工具及方式，比较耳熟能详的是一些分布式缓存：Redis和Memcached等。

在缓存与数据库之间不存在事务，引入分布式缓存，就必然会带来一个问题，即如何保证缓存与数据库的一致性，因此我们就需要一些策略来达成这个目标。

而要达成这个目标，就必须考虑一些问题：
- 删除缓存还是更新缓存？
- 先操作缓存还是先操作数据库？
- 如果缓存或者数据库操作失败怎么办？

对于缓存和数据库的操作有三种方式：
1. 先更新数据库，在更新缓存。
2. 先更新数据库，在删除缓存。
3. 先删除缓存，在更新数据库。

## 更新缓存还是删除缓存

删除缓存还是更新缓存？&emsp;&emsp;&emsp;—— **删除缓存**。

**Why?**&emsp;&emsp;有两个方面的考虑：
1. 线程安全
2. 复杂计算业务场景

> 如果业务非常简单，只是对缓存少量值进行简单的更新，那么选择更新缓存也是可以的。但相对而言，删除缓存整体操作上更加简单，并且带来的副作用只是增加了一次Cache miss，因此建议作为通用的处理方式。

## 先操作缓存还是先操作数据库

先操作缓存还是先操作数据库并不是绝对的，不管怎样，先分析一下其所存在的问题，然后在根据实际的场景去决定采用哪种方式。

**从对业务的影响角度而言：**

对一个不能保证事务性的操作而言，一定设计“那个任务先做，那个任务后做”的问题，解决这个问题的方向是：如果出现不一致，谁先做对业务影响相对较小，谁就先执行。

先操作缓存还是先操作数据库的不同影响：
- 先删除缓存，再更新数据库：先删除缓存成功，再更新数据库失败，只会引发一次Cache miss。
- 先更新数据库，再删除缓存：先更新数据库成功，再删除缓存失败，则会出现DB中是最新数据，Cache中是旧数据，数据不一致。

从上述对业务影响的角度来看，应该选择“先删除缓存，再更新数据库”。但问题在于既然该操作不能保证事务性，那么就必然存在并发问题。因此“先删除缓存，再更新数据库”不一定就是相对较好的选择。

**从并发角度而言：**

- 先删除缓存，在更新数据库。
   1. 线程A进行写操作，首先删除了缓存。
   2. 线程B查询发现缓存不存在。
   3. 线程B回源到DB中查询数据。
   4. 线程B将数据写入到缓存中。
   5. 线程A将新值写入数据库。

- 先更新数据库，在删除缓存。
   1. 缓存刚好失效。
   2. 线程A查询发现缓存不存在，回源到DB中，得到一个旧值。
   3. 线程B将新值写入数据库。
   4. 线程B删除缓存。
   5. 线程A将旧值写入缓存。

无论是先操作缓存还是先操作数据库，都会出现并发问题。相对而言“先删除缓存，在更新数据库”出现并发问题的概率远大于“先更新数据库，在删除缓存”，在高并发读写的情况下，“先删除缓存，再更新数据库”出现并发问题基本上是100%的，而“先更新数据库，再删除缓存”只有在缓存刚好失效的这个时间窗口下才可能出现并发问题。

所以，从该角度而言，应该采用“先更新数据库，在删除缓存”的策略。

到底应该采用哪种策略：

从对业务的影响角度而言，应该采用“先删除缓存，再更新数据库”策略，但其带来的并发问题使它对业务影响较小的优势荡然无存。虽然“先更新数据库，再删除缓存”策略也存在并发问题，但它出现并发问题有两个限制：
1. 刚好处在缓存失效的这个时间窗口下。
2. 步骤3的写数据库操作比步骤2读数据库操作耗时更短。
    只有耗时更短的情况下，才有可能使得步骤4先于步骤5。一般情况下，数据库的读操作速度远大于写操作（参考读写分离的目的），因此步骤3比步骤2耗时更短的情形很难出现。

因此，在不想做过多设计，增加太多工作量的情况下，优先选择“先更新数据库，在删除缓存”策略。

> “先更新数据库，再删除缓存”策略的并发问题发生概率虽然比较小，但并不是绝对不发生，因此，需要为缓存设置过期时间，以使其能够保证最终一致性，是一个托底策略。
> 结合托底策略，也可以得出优先选择“先更新数据库，在删除缓存”策略。如果选择“先删除缓存，再更新数据库”策略，出现缓存与数据库不一致的key频繁增加，虽然有过期时间进行托底，但对程序的影响还是很大。

## 延时双删

分析了两种策略的利弊，结论是优先选择“先更新数据库，再删除缓存”策略，但这并不表示“先删除缓存，再更新数据库”策略就是不可行的。有了托底策略，我们只需要降低其并发问题发生的概率，也是可以选择“先删除缓存，再更新数据库”策略。

**延时双删策略**

**先删除缓存，再更新数据库：**
1. 先删除缓存
2. 再更新数据库
3. 延时1秒，再次删除缓存

并发流程
   1. 线程A进行写操作，首先删除了缓存。
   2. 线程B查询发现缓存不存在。
   3. 线程B回源到DB中查询数据。
   4. 线程B将数据写入到缓存中。
   5. 线程A将新值写入数据库。
   6. 线程A延时了1秒，再次删除缓存。

> 步骤4和步骤5交换的。

**先更新数据库，再删除缓存：**
1. 先更新数据库
2. 再删除缓存
3. 延时1秒，再次删除缓存

并发流程
   1. 缓存刚好失效。
   2. 线程A查询发现缓存不存在，回源到DB中，得到一个旧值。
   3. 线程B将新值写入数据库。
   4. 线程B删除缓存。
   5. 线程A将旧值写入缓存。
   6. 线程B延时1秒，再次删除缓存。

注意：延时双删策略仅仅是降低了并发问题产生的概率，但只要不能保证事务性，并发问题就一定会产生的。延时双删策略是有托底策略保障最终一致性的。

> 下面是采用了延时双删策略也出现的并发问题：
> - 先删除缓存，再更新数据库
>    1. 线程A进行写操作，首先删除了缓存。
>    2. 线程B查询发现缓存不存在。
>    3. 线程B回源到DB中查询数据。
>    4. 线程A将新值写入数据库。
>    5. 线程A延时了1秒，再次删除缓存。
>    6. 线程B将数据写入到缓存中。
> 
> 不知道啥原因，线程B就是很慢，线程A即使延迟删除了，线程B也在线程A延迟删除之后才进行写缓存操作。
> 
> - 先更新数据库，再删除缓存
>    1. 缓存刚好失效。
>    2. 线程A查询发现缓存不存在，回源到DB中，得到一个旧值。
>    3. 线程B将新值写入数据库。
>    4. 线程B删除缓存。
>    5. 线程B延时1秒，再次删除缓存。
>    6. 线程A将旧值写入缓存。
> 
> 也是不知道啥原因，线程A就是很慢，线程B即使延迟删除了，线程A也在线程B延迟删除之后才进行写缓存操作。

**问题**
1. 延时时间如何确定？
    需要自行评估读操作的逻辑耗时，然后写操作的休眠时间在读操作的逻辑耗时的基础上加上几百毫秒即可。
2. 同步延时双删策略，吞吐量降低如何处理？
    第二次删除操作新启一线程异步处理。

## 删除缓存失败

到目前为止，我们降低了并发问题产生的概率，并且提供了托底策略保证了最终一致性。虽然不能保证强一致性，但看起来问题已经解决了。但还有一个很关键的问题没有考虑到：缓存删除操作失败了怎么办？缓存删除操作失败在集群节点较多的情况下出现的概率也是很高的，比如节点宕机，网络抖动等。

有两种解决方案：
1. 异步消息队列。
2. MySQL binlog。

### 异步消息队列

异步消息队列方案流程图如下：


异步消息队列方案流程：
1. 更新数据库数据。
2. 因为未知原因，缓存删除失败。
3. 将需要删除的缓存KEY发送至MQ队列。
4. 应用程序订阅该消息进行消费。
5. 继续重试缓存删除操作，直到成功。

缺点：对业务代码造成大量入侵。虽然可以将订阅MQ和重试的操作另起服务完成，但检测缓存删除失败和发送缓存KEY至MQ队列的操作是必须要嵌入到业务代码中的。

### MySQL binlog

MySQL binlog方案流程图如下：


MySQL binlog方案流程：
1. 更新数据库数据。
2. MySQL写入binlog日志。
3. 订阅binlog日志，提取出需要删除缓存相关的数据以及KEY。
4. 另起一段非业务应用程序，读取该信息。
5. 尝试删除缓存操作，如果缓存删除成功，操作结束。
6. 缓存删除失败，将需要删除的缓存KEY发送至MQ队列。
7. 非业务应用程序订阅该消息进行消费。
8. 继续重试缓存删除操作，直到成功。


## 最终一致性

一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。同时，一致性也是指事务的基本特征或特性相同，其他特性或特征相类似

一致性又可以分为强一致性与弱一致性。
1.强一致性
强一致性可以理解为在任意时刻，所有节点中的数据是一样的。同一时间点，你在节点A中获取到key1的值与在节点B中获取到key1的值应该都是一样的。
2.弱一致性
弱一致性包含很多种不同的实现，分布式系统中广泛实现的是最终一致性。
3.最终一致性
所谓最终一致性，是弱一致性的一种特例，保证用户最终能够读取到某操作对系统特定数据的更新。但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。也可以简单的理解为在一段时间后，节点间的数据会最终达到一致状态。对于最终一致性最好的例子就是DNS系统，由于DNS多级缓存的实现，所以修改DNS记录后不会在全球所有DNS服务节点生效，需要等待DNS服务器缓存过期后向源服务器更新新的记录才能实现。只要求一个对象的全部副本的最后结果是相同的和正确的，而不要求其中间状态是一致的。

## 总结
- 在不想做过多设计，增加太多工作量的情况下，优先采用“先更新数据库，在删除缓存”策略。
- 为缓存设置过期时间，保障最终一致性。
- 如果不考虑缓存删除失败的问题，建议增加延时双删策略。
- 如果要考虑缓存删除失败的问题，建议采用MySQL binlog策略。

